<!DOCTYPE html>
<html lang="en"><head><meta charset="UTF-8"/><meta name="viewport" content="width=device-width, initial-scale=1.0"/><title>connections Â· toolips</title><script data-outdated-warner src="../assets/warner.js"></script><link href="https://cdnjs.cloudflare.com/ajax/libs/lato-font/3.0.0/css/lato-font.min.css" rel="stylesheet" type="text/css"/><link href="https://cdnjs.cloudflare.com/ajax/libs/juliamono/0.044/juliamono.css" rel="stylesheet" type="text/css"/><link href="https://cdnjs.cloudflare.com/ajax/libs/font-awesome/5.15.3/css/fontawesome.min.css" rel="stylesheet" type="text/css"/><link href="https://cdnjs.cloudflare.com/ajax/libs/font-awesome/5.15.3/css/solid.min.css" rel="stylesheet" type="text/css"/><link href="https://cdnjs.cloudflare.com/ajax/libs/font-awesome/5.15.3/css/brands.min.css" rel="stylesheet" type="text/css"/><link href="https://cdnjs.cloudflare.com/ajax/libs/KaTeX/0.13.11/katex.min.css" rel="stylesheet" type="text/css"/><script>documenterBaseURL=".."</script><script src="https://cdnjs.cloudflare.com/ajax/libs/require.js/2.3.6/require.min.js" data-main="../assets/documenter.js"></script><script src="../siteinfo.js"></script><script src="../../versions.js"></script><link class="docs-theme-link" rel="stylesheet" type="text/css" href="../assets/themes/documenter-dark.css" data-theme-name="documenter-dark" data-theme-primary-dark/><link class="docs-theme-link" rel="stylesheet" type="text/css" href="../assets/themes/documenter-light.css" data-theme-name="documenter-light" data-theme-primary/><script src="../assets/themeswap.js"></script></head><body><div id="documenter"><nav class="docs-sidebar"><a class="docs-logo" href="../"><img src="../assets/logo.png" alt="toolips logo"/></a><div class="docs-package-name"><span class="docs-autofit"><a href="../">toolips</a></span></div><form class="docs-search" action="../search/"><input class="docs-search-query" id="documenter-search-query" name="q" type="text" placeholder="Search docs"/></form><ul class="docs-menu"><li><span class="tocitem">essentials</span><ul><li><a class="tocitem" href="../">toolips?</a></li><li><a class="tocitem" href="../projects/">creating projects</a></li><li><a class="tocitem" href="../routing/">routing</a></li><li class="is-active"><a class="tocitem" href>connections</a><ul class="internal"><li><a class="tocitem" href="#routes"><span>routes</span></a></li><li><a class="tocitem" href="#extensions"><span>extensions</span></a></li><li><a class="tocitem" href="#servables-basics"><span>servables basics</span></a></li><li><a class="tocitem" href="#writing"><span>writing</span></a></li><li><a class="tocitem" href="#arguments-and-posts"><span>arguments and posts</span></a></li><li><a class="tocitem" href="#controlling-connections"><span>controlling connections</span></a></li></ul></li><li><a class="tocitem" href="../core/">servers</a></li><li><a class="tocitem" href="../cli/">command-line interface</a></li><li><a class="tocitem" href="../requests/">requests</a></li><li><a class="tocitem" href="../composing_websites/">composing websites</a></li><li><a class="tocitem" href="../deploying_projects/">deploying projects</a></li></ul></li><li><span class="tocitem">servables</span><ul><li><a class="tocitem" href="../servables/components/">components</a></li><li><a class="tocitem" href="../servables/styles/">styles</a></li><li><a class="tocitem" href="../servables/animations/">animations</a></li><li><a class="tocitem" href="../servables/creating_servables/">creating servables</a></li></ul></li><li><span class="tocitem">server extensions</span><ul><li><a class="tocitem" href="../extensions/toolips_extensions/">default extensions</a></li><li><a class="tocitem" href="../extensions/toolips_session/">toolips session</a></li><li><a class="tocitem" href="../extensions/toolips_defaults/">toolips defaults</a></li><li><a class="tocitem" href="../extensions/toolips_markdown/">toolips markdown</a></li><li><a class="tocitem" href="../extensions/toolips_memwrite/">toolips memwrite</a></li><li><a class="tocitem" href="../extensions/toolips_base64/">toolips base64</a></li><li><a class="tocitem" href="../extensions/toolips_remote/">toolips remote</a></li><li><a class="tocitem" href="../extensions/toolips_uploader/">toolips uploader</a></li><li><a class="tocitem" href="../extensions/toolips_canvas/">toolips canvas</a></li><li><a class="tocitem" href="../extensions/toolips_auth/">toolips auth</a></li><li><a class="tocitem" href="../extensions/creating_extensions/">creating extensions</a></li></ul></li><li><span class="tocitem">examples</span><ul><li><a class="tocitem" href="../examples/simple_website/">simple website</a></li><li><a class="tocitem" href="../examples/blog/">blog</a></li><li><a class="tocitem" href="../examples/text_editor/">text editor</a></li><li><a class="tocitem" href="../examples/sound_share/">sound sharing platform</a></li><li><a class="tocitem" href="../examples/file_explorer/">file explorer</a></li><li><a class="tocitem" href="../examples/interactive_dash/">interactive dashboard</a></li></ul></li><li><a class="tocitem" href="../developer_api/">developer API</a></li></ul><div class="docs-version-selector field has-addons"><div class="control"><span class="docs-label button is-static is-size-7">Version</span></div><div class="docs-selector control is-expanded"><div class="select is-fullwidth is-size-7"><select id="documenter-version-selector"></select></div></div></div></nav><div class="docs-main"><header class="docs-navbar"><nav class="breadcrumb"><ul class="is-hidden-mobile"><li><a class="is-disabled">essentials</a></li><li class="is-active"><a href>connections</a></li></ul><ul class="is-hidden-tablet"><li class="is-active"><a href>connections</a></li></ul></nav><div class="docs-right"><a class="docs-edit-link" href="https://github.com/ChifiSource/Toolips.jl" title="Edit on GitHub"><span class="docs-icon fab">ï‚›</span><span class="docs-label is-hidden-touch">Edit on GitHub</span></a><a class="docs-settings-button fas fa-cog" id="documenter-settings-button" href="#" title="Settings"></a><a class="docs-sidebar-button fa fa-bars is-hidden-desktop" id="documenter-sidebar-button" href="#"></a></div></header><article class="content" id="documenter-page"><link rel="preconnect" href="https://fonts.googleapis.com">
<link rel="preconnect" href="https://fonts.gstatic.com" crossorigin>
<link href="https://fonts.googleapis.com/css2?family=Poppins&family=Roboto+Mono:wght@100&family=Rubik:wght@500&display=swap" rel="stylesheet">

<style>
body {background-color: #FDF8FF !important;}
header {background-color: #FDF8FF !important}
h1 {
  font-family: 'Poppins', sans-serif !important;
  font-family: 'Roboto Mono', monospace !important;
  font-family: 'Rubik', sans-serif !important;}

  h2 {
    font-family: 'Poppins', sans-serif !important;
    font-family: 'Roboto Mono', monospace !important;
    font-family: 'Rubik', sans-serif !important;}
    h4 { color: #03045e !important;
      font-family: 'Poppins', sans-serif !important;
      font-family: 'Roboto Mono', monospace !important;
      font-family: 'Rubik', sans-serif !important;}
article {
  border-radius: 30px !important;
  border-color: lightblue !important;
}
pre {
  border-radius: 10px !important;
  border-color: #FFE5B4 !important;
}
p {font-family: 'Poppins', sans-serif;
font-family: 'Roboto Mono', monospace;
font-family: 'Rubik', sans-serif; color: #565656;}
</style><h1 id="connections"><a class="docs-heading-anchor" href="#connections">connections</a><a id="connections-1"></a><a class="docs-heading-anchor-permalink" href="#connections" title="Permalink"></a></h1><p>A <code>Connection</code> is passed as a single positional argument to every <code>Route</code>. The <code>Connection</code> contains the output stream that content is to be written to, a <code>Dict{Symbol, ServerExtension}</code> of Server Extensions, which can be accessed by indexing the <code>Connection</code> with a <code>Symbol</code>, and a <code>Dict{String, Function}</code> of routes that the server references. A different type of Connection can also be provided to a <code>ServerTemplate</code> in order to extend capabilities, but the new <code>AbstractConnection</code> must follow the consistencies of that type.</p><article class="docstring"><header><a class="docstring-binding" id="Toolips.AbstractConnection" href="#Toolips.AbstractConnection"><code>Toolips.AbstractConnection</code></a> â€” <span class="docstring-category">Type</span></header><section><div><p><strong>abstract type AbstractConnection</strong></p><p>Connections are passed through function routes and can have Servables written     to it.</p><p><strong>Consistencies</strong></p><ul><li>routes::Dict - A {String, Function} dictionary that the server references to</li></ul><p>direct incoming connections.</p><ul><li>http::Any - Usually an HTTP.Stream, however can be anything that is binded to</li></ul><p>the Base.write method.</p><ul><li>extensions::Dict - A {Symbol, ServerExtension} dictionary that can be used to</li></ul><p>access ServerExtensions.</p></div></section></article><article class="docstring"><header><a class="docstring-binding" id="Toolips.Connection" href="#Toolips.Connection"><code>Toolips.Connection</code></a> â€” <span class="docstring-category">Type</span></header><section><div><p><strong>Connection &lt;: AbstractConnection</strong></p><ul><li>routes::Dict</li><li>http::HTTP.Stream</li><li>extensions::Dict</li></ul><p>The connection type is passed into route functions and pages as an argument. This is both for functions, as well as Servable.f() methods. This constructor     should not be called directly. Instead, it is called by the server and     passed through the function pipeline. Indexing a Connection will return         the extension named with that symbol.</p><p><strong>example</strong></p><pre><code class="nohighlight hljs">                  #  v The Connection
home = route(&quot;/&quot;) do c::Connection
    c[Logger].log(1, &quot;We can index extensions by type or symbol&quot;)
    c[:logger].log(1, &quot;see?&quot;)
    c.routes[&quot;/&quot;] = c::Connection -&gt; write!(c, &quot;rerouting!&quot;)
    httpstream = c.http
    write!(c, &quot;Hello world!&quot;)
    myheading::Component = h(&quot;myheading&quot;, 1, text = &quot;Whoa!&quot;)
    write!(c, myheading)
end</code></pre><hr/><p><strong>field info</strong></p><ul><li><strong>routes::Dict</strong> - A dictionary of routes where the keys</li></ul><p>are the routed URL and the values are the functions to those keys.</p><ul><li><strong>http::HTTP.Stream</strong> - The stream for this current peer&#39;s connection.</li><li><strong>extensions::Dict</strong> - A dictionary of extensions to load with the</li></ul><p><strong>name to reference as keys and the extension as the pair.</strong></p><p><strong>constructors</strong></p><ul><li>Connection(routes::Dict, http::HTTP.Stream, extensions::Dict)</li></ul></div></section></article><h2 id="routes"><a class="docs-heading-anchor" href="#routes">routes</a><a id="routes-1"></a><a class="docs-heading-anchor-permalink" href="#routes" title="Permalink"></a></h2><p>Connection constructors, aside from the <a href="developer_api/index.html#Toolips.SpoofConnection">SpoofConnection</a>, which is meant to be used solely for development of extensions, should not be called directly. Instead, Connections should be passed as an argument into routes.</p><pre><code class="language-julia hljs">using Toolips

thisroute = route(&quot;/&quot;) do c::Connection

end
function thisroute(c::Connection)

end</code></pre><p>Connections also contain the routes that are provided to your <code>ServerTemplate</code>. We can obtain all routes by using the <code>routes</code> method.</p><article class="docstring"><header><a class="docstring-binding" id="Toolips.routes-Tuple{AbstractConnection}" href="#Toolips.routes-Tuple{AbstractConnection}"><code>Toolips.routes</code></a> â€” <span class="docstring-category">Method</span></header><section><div><p><strong>Interface</strong></p><p><strong>routes(c::Connection) -&gt; ::Dict{String, Function}</strong></p><hr/><p>Returns the server&#39;s routes.</p><p><strong>example</strong></p><pre><code class="nohighlight hljs">route(&quot;/&quot;) do c::Connection
    routes(c)
end</code></pre></div></section></article><p>The routes can also be set, or retrieved using <code>setindex!</code> and <code>getindex!</code> with a <code>String</code> respectively.</p><pre><code class="language-julia hljs">using Toolips

function example(c::Connection)
  write!(c, &quot;hello world!&quot;)
end
myroute = route(&quot;/&quot;) do c::Connection
  c[&quot;/helloworld&quot;] = example
  this_function = c[&quot;/&quot;]
end</code></pre><article class="docstring"><header><a class="docstring-binding" id="Base.setindex!-Tuple{AbstractConnection, Function, String}" href="#Base.setindex!-Tuple{AbstractConnection, Function, String}"><code>Base.setindex!</code></a> â€” <span class="docstring-category">Method</span></header><section><div><p><strong>Interface</strong></p><p><strong>setindex!(c::AbstractConnection, f::Function, s::String) -&gt; _</strong></p><hr/><p>Sets the route path s to serve at the function f.</p><p><strong>example</strong></p><pre><code class="nohighlight hljs">c[&quot;/&quot;] = c -&gt; write!(c, &quot;hello&quot;)</code></pre></div></section></article><article class="docstring"><header><a class="docstring-binding" id="Base.getindex-Tuple{AbstractConnection, String}" href="#Base.getindex-Tuple{AbstractConnection, String}"><code>Base.getindex</code></a> â€” <span class="docstring-category">Method</span></header><section><div><p><strong>Interface</strong></p><p><strong>getindex(c::AbstractConnection, s::String) -&gt; ::Function</strong></p><hr/><p>Returns the function that corresponds to the route dir s.</p><p><strong>example</strong></p><pre><code class="nohighlight hljs">c[&quot;/&quot;]

    home</code></pre></div></section></article><p>Another technique we could also use is the <code>route!</code> method.</p><pre><code class="language-julia hljs">using Toolips

function example(c::Connection)
  write!(c, &quot;hello world!&quot;)
end
myroute = route(&quot;/&quot;) do c::Connection
  route!(c, &quot;/helloworld&quot;) do c::Connection
    write!(c, &quot;hello world!&quot;)
  end
end</code></pre><h2 id="extensions"><a class="docs-heading-anchor" href="#extensions">extensions</a><a id="extensions-1"></a><a class="docs-heading-anchor-permalink" href="#extensions" title="Permalink"></a></h2><p>A <code>Connection</code> also carries some of the extensions loaded into a <code>ServerTemplate</code>. Note that this is not always the case, as some extensions are not loaded into the Connection to work. We can access the extensions with the <code>extensions</code> method.</p><pre><code class="language-julia hljs">using Toolips

myroute = route(&quot;/&quot;) do c::Connection
  ourextensions = extensions(c)
end</code></pre><p>We can also check for a <code>Connection</code> extension by using the <code>has_extension</code> method.</p><pre><code class="language-julia hljs">using Toolips

myroute = route(&quot;/&quot;) do c::Connection
  if has_extension(c, Logger)
    c[:Logger].log(&quot;Hello world!&quot;)
  end
end</code></pre><p>Extensions can be accessed by indexing a <code>Connection</code> or <code>WebServer</code> with a <code>Symbol</code>. The <code>ServerExtension</code>&#39;s <code>Symbol</code> will be the type as a <code>Symbol</code>. We can also index with a <code>Type</code> directly.</p><article class="docstring"><header><a class="docstring-binding" id="Base.getindex-Tuple{AbstractConnection, Symbol}" href="#Base.getindex-Tuple{AbstractConnection, Symbol}"><code>Base.getindex</code></a> â€” <span class="docstring-category">Method</span></header><section><div><p><strong>Interface</strong></p><p><strong>getindex(c::AbstractConnection, s::Symbol) -&gt; ::ServerExtension</strong></p><hr/><p>Indexes the extensions in c.</p><p><strong>example</strong></p><pre><code class="nohighlight hljs">route(&quot;/&quot;) do c::Connection
    c[:Logger].log(&quot;hi&quot;)
end</code></pre></div></section></article><article class="docstring"><header><a class="docstring-binding" id="Base.getindex-Tuple{AbstractConnection, Type}" href="#Base.getindex-Tuple{AbstractConnection, Type}"><code>Base.getindex</code></a> â€” <span class="docstring-category">Method</span></header><section><div><p><strong>Interface</strong></p><p><strong>getindex(c::AbstractConnection, t::Type) -&gt; ::ServerExtension</strong></p><hr/><p>Indexes the extensions in c by type.</p><p><strong>example</strong></p><pre><code class="nohighlight hljs">route(&quot;/&quot;) do c::Connection
    c[Logger].log(&quot;hi&quot;)
end</code></pre></div></section></article><h2 id="servables-basics"><a class="docs-heading-anchor" href="#servables-basics">servables basics</a><a id="servables-basics-1"></a><a class="docs-heading-anchor-permalink" href="#servables-basics" title="Permalink"></a></h2><p>Servables are types that can be written to a <code>Connection</code>. This is done via the <code>Servable.f(::Connection)</code> method, which essentially becomes a <code>Route</code> inside of a <code>Type</code>. The main type of <a href=".">Servable</a> that comes with the toolips base is the <code>Component</code>. There are several methods that can be used to construct a <code>Component</code>, and a full list of the <code>Component</code>s that come with toolips are available <a href="servables/components/index.html">here</a>. For the following example, I will be using the <code>p</code> and <code>divider</code> Components. These are both equivalent to writing their tags in HTML, <code>&lt;p&gt;</code> and <code>&lt;div&gt;</code>. All Components take an infinite number of key-word arguments, which are element properties in HTML.</p><pre><code class="language-julia hljs">myroute = route(&quot;/&quot;) do c::Connection
# name - vvvvv | vvvvvvvvvvvvvv - setting text
  myp = p(&quot;myp&quot;, text = &quot;Hello world!&quot;)
  mydiv = divider(&quot;mydiv&quot;)
end</code></pre><h2 id="writing"><a class="docs-heading-anchor" href="#writing">writing</a><a id="writing-1"></a><a class="docs-heading-anchor-permalink" href="#writing" title="Permalink"></a></h2><p>All writing can be done via the <code>write!</code> method. We can write any type this way, as well as several different <code>Vector</code>s.</p><article class="docstring"><header><a class="docstring-binding" id="Toolips.write!" href="#Toolips.write!"><code>Toolips.write!</code></a> â€” <span class="docstring-category">Function</span></header><section><div><p><strong>Interface</strong></p><p><strong>write!(c::AbstractConnection, s::Servable) -&gt; _</strong></p><hr/><p>Writes a Servable&#39;s return to a Connection&#39;s stream. This is usually used in a routing function or a route where ::Connection is provided as an argument.</p><p><strong>example</strong></p><pre><code class="nohighlight hljs">serv = p(&quot;mycomp&quot;, text = &quot;hello&quot;)

rt = route(&quot;/&quot;) do c::Connection
    write!(c, serv)
end</code></pre></div></section><section><div><p><strong>Interface</strong></p><p><strong>write!(c::AbstractConnection, s::Vector{Servable}) -&gt; _</strong></p><hr/><p>Writes all servables in s to c.</p><p><strong>example</strong></p><pre><code class="nohighlight hljs">c = Component()
c2 = Component()
comps = components(c, c2)
    Vector{Servable}(Component(), Component())

write!(c, comps)</code></pre></div></section><section><div><p><strong>Interface</strong></p><p><strong>write!(c::AbstractConnection, s::Servable ...) -&gt; _</strong></p><hr/><p>Writes Servables as Vector{Servable}</p><p><strong>example</strong></p><pre><code class="nohighlight hljs">write!(c, p(&quot;mycomp&quot;, text = &quot;hello!&quot;), p(&quot;othercomp&quot;, text = &quot;hi!&quot;))</code></pre></div></section><section><div><p><strong>Interface</strong></p><p><strong>write!(c::AbstractConnection, s::Vector{Component}) -&gt; _</strong></p><hr/><p>A catch-all for when Vectors are accidentally stored as Vector{Any}.</p><p><strong>example</strong></p><pre><code class="nohighlight hljs">write!(c, [&quot;hello&quot;, p(&quot;mycomp&quot;, text = &quot;hello!&quot;)])</code></pre></div></section><section><div><p><strong>Interface</strong></p><p><strong>write!(c::AbstractConnection, s::Vector{Component}) -&gt; _</strong></p><hr/><p>A catch-all for when Vectors are accidentally stored as Vector{Component}.</p><p><strong>example</strong></p><pre><code class="nohighlight hljs">write!(c, [p(&quot;mycomp&quot;, text = &quot;bye&quot;)])</code></pre></div></section><section><div><p><strong>Interface</strong></p><p><strong>write!(c::AbstractConnection, s::String) -&gt; _</strong></p><hr/><p>Writes the String into the Connection as HTML.</p><p><strong>example</strong></p><pre><code class="nohighlight hljs">write!(c, &quot;hello world!&quot;)</code></pre></div></section><section><div><p><strong>Interface</strong></p><p><strong>write!(::AbstractConnection, ::Any) -&gt; _</strong></p><hr/><p>Attempts to write any type to the Connection&#39;s stream.</p><p><strong>example</strong></p><pre><code class="nohighlight hljs">d = 50
write!(c, d)</code></pre></div></section></article><p>We will compose our <code>Component</code>s from before using the <code>push!</code> method, and write them to our <code>Connection</code> using this method.</p><pre><code class="language-julia hljs">myroute = route(&quot;/&quot;) do c::Connection
# name - vvvvv | vvvvvvvvvvvvvv - setting text
  myp = p(&quot;myp&quot;, text = &quot;Hello world!&quot;)
  mydiv = divider(&quot;mydiv&quot;)
  push!(mydiv, myp)
  write!(c, mydiv)
end</code></pre><p>We can then load this into a <code>ServerTemplate</code> and use <code>st.start()</code> to reveal what has been created.</p><pre><code class="language-julia hljs">using Toolips

myroute = route(&quot;/&quot;) do c::Connection
  myp = p(&quot;myp&quot;, text = &quot;Hello world!&quot;)
  mydiv = divider(&quot;mydiv&quot;)
  push!(mydiv, myp)
  write!(c, mydiv)
end

st = ServerTemplate()
st.add(myroute)
st.start()
[2022:07:02:17:46]: ðŸŒ· toolips&gt; Toolips Server starting on port 8000
[2022:07:02:17:46]: ðŸŒ· toolips&gt; Successfully started server on port 8000
[2022:07:02:17:46]: ðŸŒ· toolips&gt; You may visit it now at http://127.0.0.1:8000</code></pre><img src = "../assets/screenshot_connection1.png"></img><h2 id="arguments-and-posts"><a class="docs-heading-anchor" href="#arguments-and-posts">arguments and posts</a><a id="arguments-and-posts-1"></a><a class="docs-heading-anchor-permalink" href="#arguments-and-posts" title="Permalink"></a></h2><p><code>Connection</code>s also hold the arguments and post bodies for a given request. GET request arguments can be obtained via the <code>getarg</code> or <code>getargs</code> methods. <code>getarg</code> will index specifically for a particular <code>Symbol</code>, whereas <code>getargs</code> will return a <code>Dict{Symbol, Any}</code> with the values parsed as <code>Any</code> by <a href="https://github.com/ChifiSource/ParseNotEval.jl">ParseNotEval</a>.</p><article class="docstring"><header><a class="docstring-binding" id="Toolips.getarg" href="#Toolips.getarg"><code>Toolips.getarg</code></a> â€” <span class="docstring-category">Function</span></header><section><div><p><strong>Interface</strong></p><p><strong>getarg(c::AbstractConnection, s::Symbol) -&gt; ::Any</strong></p><hr/><p>Returns the requested argument from the target.</p><p><strong>example</strong></p><pre><code class="nohighlight hljs">getarg(c, :x)
    50</code></pre></div></section><section><div><p><strong>Interface</strong></p><p><strong>getarg(c::AbstractConnection, s::Symbol, t::Type) -&gt; ::Vector</strong></p><hr/><p>This method is the same as getargs(::HTTP.Stream, ::Symbol), however types are parsed as type T(). Note that &quot;Cannot convert...&quot; errors are possible with this method.</p><p><strong>example</strong></p><pre><code class="nohighlight hljs">getarg(c, :x, Int64)
    50</code></pre></div></section></article><article class="docstring"><header><a class="docstring-binding" id="Toolips.getargs" href="#Toolips.getargs"><code>Toolips.getargs</code></a> â€” <span class="docstring-category">Function</span></header><section><div><p><strong>Interface</strong></p><p><strong>getargs(c::AbstractConnection) -&gt; ::Dict{Symbol, Any}</strong></p><hr/><p>The getargs method returns arguments from the HTTP target (GET requests.) Returns a Dict with the argument keys as Symbols.</p><p><strong>example</strong></p><pre><code class="nohighlight hljs">route(&quot;/&quot;) do c
    args = getargs(c)
    args[:message]
        &quot;welcome to toolips ! :)&quot;
end</code></pre></div></section></article><p>We can also get the POST body as a <code>String</code> by calling the <code>getpost</code> method.</p><article class="docstring"><header><a class="docstring-binding" id="Toolips.getpost" href="#Toolips.getpost"><code>Toolips.getpost</code></a> â€” <span class="docstring-category">Function</span></header><section><div><p><strong>Interface</strong></p><p><strong>getpost(c::AbstractConnection) -&gt; ::String</strong></p><hr/><p>Returns the POST body of c.</p><p><strong>example</strong></p><pre><code class="nohighlight hljs">getpost(c)
&quot;hello, this is a post request&quot;</code></pre></div></section></article><p>We can restart the reading of a POST by using the startread! method.</p><article class="docstring"><header><a class="docstring-binding" id="Toolips.startread!-Tuple{AbstractConnection}" href="#Toolips.startread!-Tuple{AbstractConnection}"><code>Toolips.startread!</code></a> â€” <span class="docstring-category">Method</span></header><section><div><p><strong>Interface</strong></p><p><strong>startread!(::AbstractConnection) -&gt; _</strong></p><hr/><p>Resets the seek on the Connection. This function is only meant to be used on post bodies.</p><p><strong>example</strong></p><pre><code class="nohighlight hljs">post = getpost(c)
    &quot;hello&quot;
post = getpost(c)
    &quot;&quot;
startread!(c)
post = getpost(c)
    &quot;hello&quot;</code></pre></div></section></article><h2 id="controlling-connections"><a class="docs-heading-anchor" href="#controlling-connections">controlling connections</a><a id="controlling-connections-1"></a><a class="docs-heading-anchor-permalink" href="#controlling-connections" title="Permalink"></a></h2><p>Controlling a <code>Connection</code> is relatively straightforward, we can navigate a <code>Connection</code> to a new URL using the <code>navigate!</code> method:</p><article class="docstring"><header><a class="docstring-binding" id="Toolips.navigate!" href="#Toolips.navigate!"><code>Toolips.navigate!</code></a> â€” <span class="docstring-category">Function</span></header><section><div><p><strong>Interface</strong></p><p><strong>navigate!(::AbstractConnection, ::String) -&gt; _</strong></p><hr/><p>Routes a connected stream to a given URL.</p><p><strong>example</strong></p><pre><code class="nohighlight hljs">navigate!(c, &quot;https://github.com/ChifiSource/Toolips.jl&quot;)</code></pre></div></section></article><p>We can download files using the <code>download!</code> method.</p><article class="docstring"><header><a class="docstring-binding" id="Toolips.download!" href="#Toolips.download!"><code>Toolips.download!</code></a> â€” <span class="docstring-category">Function</span></header><section><div><p><strong>Interface</strong></p><p><strong>download!(c::AbstractConnection, uri::String) -&gt; _</strong></p><hr/><p>Downloads a file to a given Connection&#39;s computer.</p><p><strong>example</strong></p><pre><code class="nohighlight hljs">download!(c, &quot;files/mytext.txt&quot;)</code></pre></div></section></article><p>Finally, we can get an incoming <code>Connection</code>&#39;s IP-Address using the <code>getip</code> function.</p><article class="docstring"><header><a class="docstring-binding" id="Toolips.getip" href="#Toolips.getip"><code>Toolips.getip</code></a> â€” <span class="docstring-category">Function</span></header><section><div><p><strong>Interface</strong></p><p><strong>getip(c::AbstractConnection) -&gt; ::String</strong></p><hr/><p>Returns the IP that is connected via the connection c.</p><p><strong>example</strong></p><pre><code class="nohighlight hljs">getip(c)
&quot;127.0.0.2&quot;</code></pre></div></section></article></article><nav class="docs-footer"><a class="docs-footer-prevpage" href="../routing/">Â« routing</a><a class="docs-footer-nextpage" href="../core/">servers Â»</a><div class="flexbox-break"></div><p class="footer-message">Powered by <a href="https://github.com/JuliaDocs/Documenter.jl">Documenter.jl</a> and the <a href="https://julialang.org/">Julia Programming Language</a>.</p></nav></div><div class="modal" id="documenter-settings"><div class="modal-background"></div><div class="modal-card"><header class="modal-card-head"><p class="modal-card-title">Settings</p><button class="delete"></button></header><section class="modal-card-body"><p><label class="label">Theme</label><div class="select"><select id="documenter-themepicker"><option value="documenter-light">documenter-light</option><option value="documenter-dark">documenter-dark</option></select></div></p><hr/><p>This document was generated with <a href="https://github.com/JuliaDocs/Documenter.jl">Documenter.jl</a> version 0.27.19 on <span class="colophon-date" title="Saturday 2 July 2022 20:16">Saturday 2 July 2022</span>. Using Julia version 1.7.2.</p></section><footer class="modal-card-foot"></footer></div></div></div></body></html>
