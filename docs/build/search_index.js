var documenterSearchIndex = {"docs":
[{"location":"core/#core","page":"core","title":"core","text":"","category":"section"},{"location":"core/","page":"core","title":"core","text":"Below is a runthrough of all of the documentation pertaining to running a Toolips server.","category":"page"},{"location":"core/#connection","page":"core","title":"connection","text":"","category":"section"},{"location":"core/","page":"core","title":"core","text":"Connection","category":"page"},{"location":"core/#Toolips.Connection","page":"core","title":"Toolips.Connection","text":"Connection <: AbstractConnection\n\nroutes::Dict\nhttp::HTTP.Stream\nextensions::Dict\n\nThe connection type is passed into route functions and pages as an argument. This is both for functions, as well as Servable.f() methods. This constructor     should not be called directly. Instead, it is called by the server and     passed through the function pipeline. Indexing a Connection will return         the extension named with that symbol.\n\nexample\n\n                  #  v The Connection\nhome = route(\"/\") do c::Connection\n    c[Logger].log(1, \"We can index extensions by type or symbol\")\n    c[:logger].log(1, \"see?\")\n    c.routes[\"/\"] = c::Connection -> write!(c, \"rerouting!\")\n    httpstream = c.http\n    write!(c, \"Hello world!\")\n    myheading::Component = h(\"myheading\", 1, text = \"Whoa!\")\n    write!(c, myheading)\nend\n\n\n\nfield info\n\nroutes::Dict - A dictionary of routes where the keys\n\nare the routed URL and the values are the functions to those keys.\n\nhttp::HTTP.Stream - The stream for this current peer's connection.\nextensions::Dict - A dictionary of extensions to load with the\n\nname to reference as keys and the extension as the pair.\n\nconstructors\n\nConnection(routes::Dict, http::HTTP.Stream, extensions::Dict)\n\n\n\n\n\n","category":"type"},{"location":"core/","page":"core","title":"core","text":"Connections are served as an argument to incoming routes. Functions are written anticipating a connection return. Here we will write a new route using the route(::Function, ::String) method.","category":"page"},{"location":"core/","page":"core","title":"core","text":"using Toolips\nr = route(\"/\") do c::Connection\n    write!(c, \"Hello!\")\nend","category":"page"},{"location":"core/","page":"core","title":"core","text":"We also use the write!() method on our Connection. We can use this on the types ::Any, ::Vector{Servable}, and ::Servable.","category":"page"},{"location":"core/","page":"core","title":"core","text":"write!","category":"page"},{"location":"core/#Toolips.write!","page":"core","title":"Toolips.write!","text":"Interface\n\nwrite!(c::AbstractConnection, s::Servable) -> _\n\n\n\nWrites a Servable's return to a Connection's stream. This is usually used in a routing function or a route where ::Connection is provided as an argument.\n\nexample\n\nserv = p(\"mycomp\", text = \"hello\")\n\nrt = route(\"/\") do c::Connection\n    write!(c, serv)\nend\n\n\n\n\n\nInterface\n\nwrite!(c::AbstractConnection, s::Vector{Servable}) -> _\n\n\n\nWrites all servables in s to c.\n\nexample\n\nc = Component()\nc2 = Component()\ncomps = components(c, c2)\n    Vector{Servable}(Component(), Component())\n\nwrite!(c, comps)\n\n\n\n\n\n\n\n\n\nInterface\n\nwrite!(c::AbstractConnection, s::String) -> _\n\n\n\nWrites the String into the Connection as HTML.\n\nexample\n\nwrite!(c, \"hello world!\")\n\n\n\n\n\nInterface\n\nwrite!(::AbstractConnection, ::Any) -> _\n\n\n\nAttempts to write any type to the Connection's stream.\n\nexample\n\nd = 50\nwrite!(c, d)\n\n\n\n\n\n","category":"function"},{"location":"core/","page":"core","title":"core","text":"Or push any data response into a body and startread the body.","category":"page"},{"location":"core/","page":"core","title":"core","text":"push!(::AbstractConnection, ::Any)\nToolips.startread!(::AbstractConnection)\nToolips.extensions(::Connection)\nroutes(::AbstractConnection)\nhas_extension(::AbstractConnection, ::Type)","category":"page"},{"location":"core/#Base.push!-Tuple{AbstractConnection, Any}","page":"core","title":"Base.push!","text":"Interface\n\npush!(c::AbstractConnection, data::Any) -> _\n\n\n\nA \"catch-all\" for pushing data to a stream. Produces a full response with data as the body.\n\nexample\n\n\n\n\n\n\n\n","category":"method"},{"location":"core/#Toolips.startread!-Tuple{AbstractConnection}","page":"core","title":"Toolips.startread!","text":"Interface\n\nstartread!(::AbstractConnection) -> _\n\n\n\nResets the seek on the Connection. This function is only meant to be used on post bodies.\n\nexample\n\npost = getpost(c)\n    \"hello\"\npost = getpost(c)\n    \"\"\nstartread!(c)\npost = getpost(c)\n    \"hello\"\n\n\n\n\n\n","category":"method"},{"location":"core/#Toolips.extensions-Tuple{Connection}","page":"core","title":"Toolips.extensions","text":"Interface\n\nextensions(c::Connection) -> ::Dict{Symbol, ServerExtension}\n\n\n\nReturns the server's extensions.\n\nexample\n\nroute(\"/\") do c::Connection\n    extensions(c)\nend\n\n\n\n\n\n","category":"method"},{"location":"core/#Toolips.routes-Tuple{AbstractConnection}","page":"core","title":"Toolips.routes","text":"Interface\n\nroutes(c::Connection) -> ::Dict{String, Function}\n\n\n\nReturns the server's routes.\n\nexample\n\nroute(\"/\") do c::Connection\n    routes(c)\nend\n\n\n\n\n\n","category":"method"},{"location":"core/#Toolips.has_extension-Tuple{AbstractConnection, Type}","page":"core","title":"Toolips.has_extension","text":"Interface\n\nhas_extension(c::AbstractConnection, t::Type) -> ::Bool\n\n\n\nChecks if c.extensions has an extension of type t.\n\nexample\n\nif has_extension(c, Logger)\n    c[:Logger].log(\"it has a logger, I think.\")\nend\n\n\n\n\n\n","category":"method"},{"location":"core/","page":"core","title":"core","text":"The connection type can be indexed with Symbols, Strings, and Types. Symbols and Types will index the extensions. Strings will index the routes. The same goes for setting the indexes.","category":"page"},{"location":"core/","page":"core","title":"core","text":"setindex!(::AbstractConnection, ::Function, ::String)\ngetindex(::AbstractConnection, ::Symbol)\ngetindex(::AbstractConnection, ::Type)\ngetindex(::AbstractConnection, ::String)","category":"page"},{"location":"core/#Base.setindex!-Tuple{AbstractConnection, Function, String}","page":"core","title":"Base.setindex!","text":"Interface\n\nsetindex!(c::AbstractConnection, f::Function, s::String) -> _\n\n\n\nSets the route path s to serve at the function f.\n\nexample\n\nc[\"/\"] = c -> write!(c, \"hello\")\n\n\n\n\n\n","category":"method"},{"location":"core/#Base.getindex-Tuple{AbstractConnection, Symbol}","page":"core","title":"Base.getindex","text":"Interface\n\ngetindex(c::AbstractConnection, s::Symbol) -> ::ServerExtension\n\n\n\nIndexes the extensions in c.\n\nexample\n\nroute(\"/\") do c::Connection\n    c[:Logger].log(\"hi\")\nend\n\n\n\n\n\n","category":"method"},{"location":"core/#Base.getindex-Tuple{AbstractConnection, Type}","page":"core","title":"Base.getindex","text":"Interface\n\ngetindex(c::AbstractConnection, t::Type) -> ::ServerExtension\n\n\n\nIndexes the extensions in c by type.\n\nexample\n\nroute(\"/\") do c::Connection\n    c[Logger].log(\"hi\")\nend\n\n\n\n\n\n","category":"method"},{"location":"core/#Base.getindex-Tuple{AbstractConnection, String}","page":"core","title":"Base.getindex","text":"Interface\n\ngetindex(c::AbstractConnection, s::String) -> ::Function\n\n\n\nReturns the function that corresponds to the route dir s.\n\nexample\n\nc[\"/\"]\n\n    home\n\n\n\n\n\n","category":"method"},{"location":"core/","page":"core","title":"core","text":"We also use the Connection in order to get arguments, download files, and pretty much anything else pertaining to a person's connection.","category":"page"},{"location":"core/","page":"core","title":"core","text":"getarg\ngetargs\ngetip\ngetpost\nToolips.download!\nnavigate!","category":"page"},{"location":"core/#Toolips.getarg","page":"core","title":"Toolips.getarg","text":"Interface\n\ngetarg(c::AbstractConnection, s::Symbol) -> ::Any\n\n\n\nReturns the requested argument from the target.\n\nexample\n\ngetarg(c, :x)\n    50\n\n\n\n\n\nInterface\n\ngetarg(c::AbstractConnection, s::Symbol, t::Type) -> ::Vector\n\n\n\nThis method is the same as getargs(::HTTP.Stream, ::Symbol), however types are parsed as type T(). Note that \"Cannot convert...\" errors are possible with this method.\n\nexample\n\ngetarg(c, :x, Int64)\n    50\n\n\n\n\n\n","category":"function"},{"location":"core/#Toolips.getargs","page":"core","title":"Toolips.getargs","text":"Interface\n\ngetargs(c::AbstractConnection) -> ::Dict{Symbol, Any}\n\n\n\nThe getargs method returns arguments from the HTTP target (GET requests.) Returns a Dict with the argument keys as Symbols.\n\nexample\n\nroute(\"/\") do c\n    args = getargs(c)\n    args[:message]\n        \"welcome to toolips ! :)\"\nend\n\n\n\n\n\n","category":"function"},{"location":"core/#Toolips.getip","page":"core","title":"Toolips.getip","text":"Interface\n\ngetip(c::AbstractConnection) -> ::String\n\n\n\nReturns the IP that is connected via the connection c.\n\nexample\n\ngetip(c)\n\"127.0.0.2\"\n\n\n\n\n\n","category":"function"},{"location":"core/#Toolips.getpost","page":"core","title":"Toolips.getpost","text":"Interface\n\ngetpost(c::AbstractConnection) -> ::String\n\n\n\nReturns the POST body of c.\n\nexample\n\ngetpost(c)\n\"hello, this is a post request\"\n\n\n\n\n\n","category":"function"},{"location":"core/#Toolips.download!","page":"core","title":"Toolips.download!","text":"Interface\n\ndownload!(c::AbstractConnection, uri::String) -> _\n\n\n\nDownloads a file to a given Connection's computer.\n\nexample\n\ndownload!(c, \"files/mytext.txt\")\n\n\n\n\n\n","category":"function"},{"location":"core/#Toolips.navigate!","page":"core","title":"Toolips.navigate!","text":"Interface\n\nnavigate!(::AbstractConnection, ::String) -> _\n\n\n\nRoutes a connected stream to a given URL.\n\nexample\n\nnavigate!(c, \"https://github.com/ChifiSource/Toolips.jl\")\n\n\n\n\n\n","category":"function"},{"location":"core/","page":"core","title":"core","text":"We can also check if an extension is present by type.","category":"page"},{"location":"core/","page":"core","title":"core","text":"has_extension(::Connection, ::Type)","category":"page"},{"location":"core/#Toolips.has_extension-Tuple{Connection, Type}","page":"core","title":"Toolips.has_extension","text":"Interface\n\nhas_extension(c::AbstractConnection, t::Type) -> ::Bool\n\n\n\nChecks if c.extensions has an extension of type t.\n\nexample\n\nif has_extension(c, Logger)\n    c[:Logger].log(\"it has a logger, I think.\")\nend\n\n\n\n\n\n","category":"method"},{"location":"core/#routing","page":"core","title":"routing","text":"","category":"section"},{"location":"core/","page":"core","title":"core","text":"When routing, many methods involve the Connection type we just spoke of. In toolips, routes are handled by the Route type.","category":"page"},{"location":"core/","page":"core","title":"core","text":"Route","category":"page"},{"location":"core/#Toolips.Route","page":"core","title":"Toolips.Route","text":"Route\n\npath::String\npage::Function A route is added to a ServerTemplate using either its constructor, or the\n\nServerTemplate.add(::Route) method. Each route calls a function. The Route type is commonly constructed using the do syntax with the route(::Function, ::String) method.\n\nexample\n\n# Constructors\nroute = Route(\"/\", p(text = \"hello\"))\n\nfunction example(c::Connection)\n    write!(c, \"hello\")\nend\n\nroute = Route(\"/\", example)\n\n# method\nroute = route(\"/\") do c\n    write!(c, \"Hello world!\")\n    write!(c, p(text = \"hello\"))\n    # we can also use extensions!\n    c[:logger].log(\"hello world!\")\nend\n\n\n\nfield info\n\npath::String - The path to route to the function, e.g. \"/\".\npage::Function - The function to route the path to.\n\n\n\nconstructors\n\nRoute(path::String, f::Function)\n\n\n\n\n\n","category":"type"},{"location":"core/","page":"core","title":"core","text":"The Route's constructors are not typically called directly, instead it is probably better to use these methods. Using route! as opposed to route! will modify the routes of a Connection or ToolipsServer","category":"page"},{"location":"core/","page":"core","title":"core","text":"route\nroute!\nunroute!\nroutes","category":"page"},{"location":"core/#Toolips.route","page":"core","title":"Toolips.route","text":"Interface\n\nroute(f::Function, r::String) -> ::Route\n\n\n\nCreates a route from the Function. The function should take a Connection or AbstractConnection as a single positional argument.\n\nexample\n\nroute(\"/\") do c::Connection\n\nend\n\n\n\n\n\nInterface\n\nroute(r::String, f::Function) -> ::Route\n\n\n\nCreates a route from the Function. The function should take a Connection or AbstractConnection as a single positional argument.\n\nexample\n\nfunction example(c::Connection)\n    write!(c, h(\"myh\", 1, text = \"hello!\"))\nend\nr = route(\"/\", example)\n\n\n\n\n\n","category":"function"},{"location":"core/#Toolips.route!","page":"core","title":"Toolips.route!","text":"Interface\n\nroute!(c::AbstractConnection, route::Route) -> _\n\n\n\nModifies the route on the Connection.\n\nexample\n\nroute(\"/\") do c::Connection\n    r = route(\"/\") do c::Connection\n        write!(c, \"hello\")\n    end\n    route!(c, r)\nend\n\n\n\n\n\nInterface\n\nroute!(::Function, ::AbstractConnection, ::String) -> _\n\n\n\nRoutes a given String to the Function.\n\nexample\n\nroute(\"/\") do c\n    route!(c, \"/\") do c\n        println(\"tacos\")\n    end\nend\n\n\n\n\n\nInterface\n\nroute!(f::Function, ws::WebServer, r::String) -> _\n\n\n\nReroutes a server's route r to function f.\n\nexample\n\nws = MyProject.start()\nroute!(ws, \"/\") do c\n    c[:Logger].log(\"rerouted!\")\nend\n\n\n\n\n\nInterface\n\nroute!(ws::WebServer, r::String, f::Function) -> _\n\n\n\nReroutes a server's route r to function f.\n\nexample\n\nws = MyProject.start()\n\nfunction myf(c::Connection)\n    write!(c, \"pasta\")\nend\nroute!(ws, \"/\", myf)\n\n\n\n\n\nInterface\n\nroute!(ws::WebServer, r::Route) -> _\n\n\n\nReroutes a server's route r.\n\nexample\n\nws = MyProject.start()\nr = route(\"/\") do c\n\nend\nroute!(ws, r)\n\n\n\n\n\n","category":"function"},{"location":"core/#Toolips.unroute!","page":"core","title":"Toolips.unroute!","text":"Interface\n\nunroute!(::AbstractConnection, ::String) -> _\n\n\n\nRemoves the route with the key equivalent to the String.\n\nexample\n\n# One request will kill this route:\nroute(\"/\") do c::Connection\n    unroute!(c, \"/\")\nend\n\n\n\n\n\n","category":"function"},{"location":"core/#Toolips.routes","page":"core","title":"Toolips.routes","text":"Interface\n\nroutes(::Route ...) -> ::Vector{Route}\n\n\n\nTurns routes provided as arguments into a Vector{Route} with indexable routes. This is useful because this is the type that the ServerTemplate constructor likes. This function is also used as a \"getter\" for WebServers and Connections, see ?(routes(::WebServer)) & ?(routes(::AbstractConnection))\n\nexample\n\nr1 = route(\"/\") do c::Connection\n    write!(c, \"pickles\")\nend\nr2 = route(\"/pickles\") do c::Connection\n    write!(c, \"also pickles\")\nend\nrts = routes(r1, r2)\n\n\n\n\n\nInterface\n\nroutes(ws::WebServer) -> ::Dict{String, Function}\n\n\n\nReturns the server's routes.\n\nexample\n\nws = MyProject.start()\nroutes(ws)\n    \"/\" => home\n    \"404\" => fourohfour\n\n\n\n\n\nInterface\n\nroutes(c::Connection) -> ::Dict{String, Function}\n\n\n\nReturns the server's routes.\n\nexample\n\nroute(\"/\") do c::Connection\n    routes(c)\nend\n\n\n\n\n\n","category":"function"},{"location":"core/#servers","page":"core","title":"servers","text":"","category":"section"},{"location":"core/","page":"core","title":"core","text":"ToolipsServers are created by ServerTemplates. Here is a look at how to make a ServerTemplate:","category":"page"},{"location":"core/","page":"core","title":"core","text":"ServerTemplate","category":"page"},{"location":"core/#Toolips.ServerTemplate","page":"core","title":"Toolips.ServerTemplate","text":"ServerTemplate\n\nip::String\nport::Integer\nroutes::Vector{Route}\nextensions::Dict\nremove::Function\nadd::Function\nstart::Function The ServerTemplate is used to configure a server before\n\nrunning. These are usually made and started inside of a main server file.\n\nexample\n\nst = ServerTemplate()\n\nwebserver = ServerTemplate.start()\n\n\n\nfield info\n\nip::String - IP the server should serve to.\nport::Integer - Port to listen on.\nroutes::Vector{Route} - A vector of routes to provide to the server\nextensions::Vector{ServerExtension} - A vector of extensions to load into\n\nthe server.\n\nremove(::Int64)::Function - Removes routes by index.\nremove(::String)::Function - Removes routes by name.\nremove(::Symbol)::Function - Removes extension by Symbol representing\n\ntype, e.g. :Logger\n\nadd(::Route ...)::Function - Adds the routes to the server.\nadd(::ServerExtension ...)::Function - Adds the extensions to the server.\nstart()::Function - Starts the server.\n\n\n\nconstructors\n\nServerTemplate(ip::String = \"127.0.0.1\", port::Int64 = 8001,           routes::Vector{Route} = Vector{Route}());           extensions::Vector{ServerExtension} = [Logger()]           connection::Type)\n\n\n\n\n\n","category":"type"},{"location":"core/","page":"core","title":"core","text":"The ServerTemplate.start() function returns a sub-type of ToolipsServer.","category":"page"},{"location":"core/","page":"core","title":"core","text":"ToolipsServer\nWebServer\ngetindex(::WebServer, ::Symbol)\nToolips.routes(::WebServer)\nToolips.extensions(::WebServer)","category":"page"},{"location":"core/#Toolips.ToolipsServer","page":"core","title":"Toolips.ToolipsServer","text":"abstract type ToolipsServer\n\nToolipsServers are returned whenever the ServerTemplate.start() field is called. If you are running your server as a module, it should be noted that commonly a global start() method is used and returns this server, and dev is where this module is loaded, served, and revised.\n\nConsistencies\n\nroutes::Dict - The server's route => function dictionary.\nextensions::Dict - The server's currently loaded extensions.\nserver::Any - The server, whatever type it may be...\n\n\n\n\n\n","category":"type"},{"location":"core/#Toolips.WebServer","page":"core","title":"Toolips.WebServer","text":"\n\n\n\n","category":"type"},{"location":"core/#Base.getindex-Tuple{WebServer, Symbol}","page":"core","title":"Base.getindex","text":"Interface\n\ngetindex(ws::WebServer, s::Symbol) -> ::ServerExtension\n\n\n\nIndexes the extensions in ws.\n\nexample\n\nws = MyProject.start()\nws[:Logger].log(\"hi\")\n\n\n\n\n\n","category":"method"},{"location":"core/#Toolips.routes-Tuple{WebServer}","page":"core","title":"Toolips.routes","text":"Interface\n\nroutes(ws::WebServer) -> ::Dict{String, Function}\n\n\n\nReturns the server's routes.\n\nexample\n\nws = MyProject.start()\nroutes(ws)\n    \"/\" => home\n    \"404\" => fourohfour\n\n\n\n\n\n","category":"method"},{"location":"core/#Toolips.extensions-Tuple{WebServer}","page":"core","title":"Toolips.extensions","text":"Interface\n\nextensions(ws::WebServer) -> ::Dict{Symbol, ServerExtension}\n\n\n\nReturns the server's extensions.\n\nexample\n\nws = MyProject.start()\nextensions(ws)\n    :Logger => Logger(blah blah blah)\n\n\n\n\n\n","category":"method"},{"location":"core/#server-extensions","page":"core","title":"server extensions","text":"","category":"section"},{"location":"core/","page":"core","title":"core","text":"Server extensions are provided to the ServerTemplate type. You may read more about them in the developer api. There are also a few default extensions included with toolips. These can be used by passing them in a Symbol-labeled dictionary as the extensions key-word argument on a ServerTemplate These are Logger and Files.","category":"page"},{"location":"core/","page":"core","title":"core","text":"Logger\nFiles","category":"page"},{"location":"core/#Toolips.Logger","page":"core","title":"Toolips.Logger","text":"Logger <: ServerExtension\n\ntype::Symbol\nout::String\nlevels::Dict\nlog::Function\nprefix::String\ntimeformat::String\nwriteat::Int64 A Logger logs information with different levels. Holds the function log(),\n\nconnected to the function _log(). Methods.\n\nexample\n\nlogger = Logger()\nst = ServerTemplate(extensions = [Logger()])\nr = route(\"/\") do c::Connection\n    write!(c, \"hello world!\")\n    c[:Logger].log(\"Hello world delivered, mission accomplished.\")\nend\nst.add(r)\nst.start()\n\n\n\nfield info\n\ntype::Symbol - The type of server extension â€“ in this case, Connection.\nout::String - Logfile output directory.\nlog(level::Int64, message::String) - Logs the message at the provided level.\nlog(message::String) - Logs the message at level 1.\nlog(c::Connection, message::String) - Logs to level one and to JavaScript\n\nconsole.\n\nlevels::Dict - A {Any, Crayon} dict that contains all of the crayons for the\n\nlogger. Also contains two special crayons under the keys :timecrayon and :messagecrayon\n\nprefix::String - The prefix to write before the message.\ntimeformat::String - A string representing DT format, must be able to be\n\npassed through the datetime_str macro from Dates.\n\nwriteat::Int64 - The log level to write to out at.\n\n\n\nconstructors\n\nLogger(levels::Dict{level_count::Int64 => crayon::Crayons.Crayon};                     out::String = pwd() * \"logs/log.txt\") Logger(; out::String = pwd() * \"/logs/log.txt\")\n\n\n\n\n\n","category":"type"},{"location":"core/#Toolips.Files","page":"core","title":"Toolips.Files","text":"Files <: ServerExtension\n\ntype::Symbol\ndirectory::String\nf::Function Writes all files in directory to their own routes in the server.\n\n\n\nfield info\n\ntype::Symbol - The type of extension. There are three different selections\n\nyou can choose from. :connection :routing :func. A :connection extension will be provided in Connection.extensions. A :routing function is passed a Dict of routes as an argument. The last is a function argument, which is just a specific function to run from the top-end to the server.\n\ndirectory::String - The directory to route the files from.\nf::Function - The function f() called with a Connection.\n\n\n\nconstructors\n\nFiles(dir::String)\n\n\n\n\n\n","category":"type"},{"location":"interface/#servables","page":"servables","title":"servables","text":"","category":"section"},{"location":"interface/","page":"servables","title":"servables","text":"Servables are any non-core data-structure that is built with the objective of being written to a stream.","category":"page"},{"location":"interface/#requests","page":"servables","title":"requests","text":"","category":"section"},{"location":"interface/","page":"servables","title":"servables","text":"Toolips has some bindings that pre-parse responses fro you, these are both post and get requests.","category":"page"},{"location":"interface/","page":"servables","title":"servables","text":"get\npost","category":"page"},{"location":"interface/#Base.get","page":"servables","title":"Base.get","text":"Interface\n\nget(url::String) -> ::String\n\n\n\nQuick binding for an HTTP GET request.\n\nexample\n\nbody = get(\"/\")\n    \"hi\"\n\n\n\n\n\n","category":"function"},{"location":"interface/#Toolips.post","page":"servables","title":"Toolips.post","text":"Interface\n\npost(url::String, body::String) -> ::String\n\n\n\nQuick binding for an HTTP POST request.\n\nexample\n\nresponse = post(\"/\")\n    \"my response\"\n\n\n\n\n\n","category":"function"},{"location":"interface/#components","page":"servables","title":"components","text":"","category":"section"},{"location":"interface/","page":"servables","title":"servables","text":"A component is a Servable which contains markup information and can easily be translated into elements with properties..","category":"page"},{"location":"interface/","page":"servables","title":"servables","text":"Component","category":"page"},{"location":"interface/#Toolips.Component","page":"servables","title":"Toolips.Component","text":"Component <: Servable\n\nname::String\nf::Function\nproperties::Dict A component is a standard servable which is used to represent HTML tag\n\nstructures. Indexing a Component with a Symbol or a String will return or set a Component's property to that index. The two special indexes are :children and :text. :text will change the inner content of the Component and :children is where components that will be written inside the Component go. You can add to these with push!(c::Servable, c2::Servable)\n\nexample\n\nusing Toolips\n\nimage_style = Style(\"example\")\nimage_anim = Animation(\"img_anim\")\nimage_anim[:from] = \"opacity\" => \"0%\"\nimage_anim[:to] = \"opacity\" => \"100%\"\nanimate!(image_style)\n\nr = route(\"/\") do c::AbstractConnection\n    newimage = img(\"newimage\", src = \"/logo.png\")\n    style!(newimage, image_style)\n    write!(c, newimage)\nend\n\n\n\nfield info\n\nname::String - The name field is the way that a component is denoted in code.\nf::Function - The function that gets called with the Connection as an\n\nargument.\n\nproperties::Dict - A dictionary of symbols and values.\n\n\n\nconstructors\n\nComponent(name::String = \"\", tag::String = \"\", properties::Dict = Dict())\nComponent(name::String, tag::String, props::Base.Pairs)\n\n\n\n\n\n","category":"type"},{"location":"interface/","page":"servables","title":"servables","text":"Indexing a component will yield its .properties:","category":"page"},{"location":"interface/","page":"servables","title":"servables","text":"getindex(::Component, ::Symbol)\ngetindex(::Component, ::String)\nsetindex!(::Servable, ::Any, ::Symbol)\ngetindex(::Vector{Servable}, ::String)\nsetindex!(::Servable, ::Any, ::String)\ngetindex(::Servable, ::String)","category":"page"},{"location":"interface/#Base.getindex-Tuple{Component, Symbol}","page":"servables","title":"Base.getindex","text":"Interface\n\ngetindex(s::Component, symb::Symbol) -> ::Any\n\n\n\nReturns a property value by symbol or name.\n\nexample\n\nc = p(\"hello\", text = \"Hello world\")\nc[:text]\n    \"Hello world!\"\n\nc[\"opacity\"] = \"50%\"\nc[\"opacity\"]\n    \"50%\"\n\n\n\n\n\n","category":"method"},{"location":"interface/#Base.getindex-Tuple{Component, String}","page":"servables","title":"Base.getindex","text":"Interface\n\ngetindex(::Servable, ::String) -> ::Any\n\n\n\nReturns a property value by string or name.\n\nexample\n\nc = p(\"hello\", text = \"Hello world\")\nc[:text]\n    \"Hello world!\"\n\nc[\"opacity\"] = \"50%\"\nc[\"opacity\"]\n    \"50%\"\n\n\n\n\n\n","category":"method"},{"location":"interface/#Base.setindex!-Tuple{Servable, Any, Symbol}","page":"servables","title":"Base.setindex!","text":"Interface\n\nsetindex!(s::Servable, a::Any, symb::Symbol) -> _\n\n\n\nSets the property represented by the symbol to the provided value.\n\nexample\n\nc = p(\"world\")\nc[:text] = \"hello world!\"\n\n\n\n\n\n","category":"method"},{"location":"interface/#Base.getindex-Tuple{Vector{Servable}, String}","page":"servables","title":"Base.getindex","text":"Interface\n\ngetindex(c::VectorServable, str::String) -> ::Servable\n\n\n\nReturns the Servable (likely a Component) with the name str\n\nexample\n\ncomp1 = p(\"hello\")\ncomp2 = p(\"anotherp\")\ncs = components(comp1, comp2)\ncs[\"hello\"]\n    Component(\"hello\" ...)\n\n\n\n\n\n","category":"method"},{"location":"interface/#Base.setindex!-Tuple{Servable, Any, String}","page":"servables","title":"Base.setindex!","text":"Interface\n\nsetindex!(s::Servable, a::Any, symb::String) -> _\n\n\n\nSets the property represented by the string to the provided value. Use the appropriate web-format, such as \"50%\" or \"50px\".\n\nexample\n\nc = p(\"world\")\nc[\"align\"] = \"center\"\n\n\n\n\n\n","category":"method"},{"location":"interface/#Base.getindex-Tuple{Servable, String}","page":"servables","title":"Base.getindex","text":"Interface\n\ngetindex(::Servable, ::String) -> ::Any\n\n\n\nReturns a property value by string or name.\n\nexample\n\nc = p(\"hello\", text = \"Hello world\")\nc[:text]\n    \"Hello world!\"\n\nc[\"opacity\"] = \"50%\"\nc[\"opacity\"]\n    \"50%\"\n\n\n\n\n\n","category":"method"},{"location":"interface/","page":"servables","title":"servables","text":"There is a library of default components that comes with toolips. Generally, their name coincides with a docstring. All of these take an infinite number of key-word arguments. These arguments become the properties of a Servable.","category":"page"},{"location":"interface/","page":"servables","title":"servables","text":"img\nlink\nmeta\ninput\na\np\nh\nul\nli\ndivider\nbr\ni\ntitle\nspan\niframe\nsvg\nelement\nlabel\nscript\nnav\nbutton\nform","category":"page"},{"location":"interface/#Toolips.img","page":"servables","title":"Toolips.img","text":"img(name::String; args ...) -> ::Component\n\n\n\nReturns the img Component with the key-word arguments provided in args as properties.\n\nexample\n\nimage = img(\"mylogo\", src = \"assets/logo.png\")\nwrite!(c, image)\n\n\n\n\n\n","category":"function"},{"location":"interface/#Toolips.link","page":"servables","title":"Toolips.link","text":"link(name::String; args ...) -> ::Component\n\n\n\nReturns the link Component with the key-word arguments provided in args as properties.\n\nexample\n\nmylink = link(\"mylink\", href = \"http://toolips.app\")\nwrite!(c, mylink)\n\n\n\n\n\n","category":"function"},{"location":"interface/#Toolips.meta","page":"servables","title":"Toolips.meta","text":"meta(name::String; args ...) -> ::Component\n\n\n\nReturns the meta Component with the key-word arguments provided in args as properties.\n\nexample\n\nmetainfo = meta(\"metainfo\", rel = \"meta-description\", text = \"hello\")\nwrite!(c, metainfo)\n\n\n\n\n\n","category":"function"},{"location":"interface/#Toolips.input","page":"servables","title":"Toolips.input","text":"input(name::String; args ...) -> ::Component\n\n\n\nReturns the input Component with the key-word arguments provided in args as properties.\n\nexample\n\nelement = input(\"mylogo\")\nwrite!(c, element)\n\n\n\n\n\n","category":"function"},{"location":"interface/#Toolips.a","page":"servables","title":"Toolips.a","text":"a(name::String; args ...) -> ::Component\n\n\n\nReturns the a Component with the key-word arguments provided in args as properties.\n\nexample\n\nelement = a(\"mylogo\")\nwrite!(c, element)\n\n\n\n\n\n","category":"function"},{"location":"interface/#Toolips.p","page":"servables","title":"Toolips.p","text":"p(name::String; args ...) -> ::Component\n\n\n\nReturns the p Component with the key-word arguments provided in args as properties.\n\nexample\n\np1 = input(\"mylogo\")\nwrite!(c, p)\n\n\n\n\n\n","category":"function"},{"location":"interface/#Toolips.h","page":"servables","title":"Toolips.h","text":"h(name::String; args ...) -> ::Component\n\n\n\nReturns the h Component with the key-word arguments provided in args as properties.\n\nexample\n\nh1 = h(\"heading1\", 1)\nwrite!(c, h1)\n\n\n\n\n\n","category":"function"},{"location":"interface/#Toolips.ul","page":"servables","title":"Toolips.ul","text":"ul(name::String; args ...) -> ::Component\n\n\n\nReturns the ul Component with the key-word arguments provided in args as properties.\n\nexample\n\nul1 = ul(\"mylogo\")\nwrite!(c, ul)\n\n\n\n\n\n","category":"function"},{"location":"interface/#Toolips.li","page":"servables","title":"Toolips.li","text":"li(name::String; args ...) -> ::Component\n\n\n\nReturns the li Component with the key-word arguments provided in args as properties.\n\nexample\n\nli1 = li(\"mylogo\")\nwrite!(c, li)\n\n\n\n\n\n","category":"function"},{"location":"interface/#Toolips.divider","page":"servables","title":"Toolips.divider","text":"divider(name::String; args ...) -> ::Component\n\n\n\nReturns the div Component with the key-word arguments provided in args as properties.\n\nexample\n\ndivider1 = divider(\"mylogo\")\nwrite!(c, divider)\n\n\n\n\n\n","category":"function"},{"location":"interface/#Toolips.br","page":"servables","title":"Toolips.br","text":"br(name::String; args ...) -> ::Component\n\n\n\nReturns the br Component with the key-word arguments provided in args as properties.\n\nexample\n\ncomp = br(\"newcomp\")\nwrite!(c, comp)\n\n\n\n\n\n","category":"function"},{"location":"interface/#Toolips.i","page":"servables","title":"Toolips.i","text":"i(name::String; args ...) -> ::Component\n\n\n\nReturns the i Component with the key-word arguments provided in args as properties.\n\nexample\n\ncomp = i(\"newcomp\")\nwrite!(c, comp)\n\n\n\n\n\n","category":"function"},{"location":"interface/#Toolips.title","page":"servables","title":"Toolips.title","text":"title(name::String; args ...) -> ::Component\n\n\n\nReturns the title Component with the key-word arguments provided in args as properties.\n\nexample\n\ncomp = title(\"newcomp\")\nwrite!(c, comp)\n\n\n\n\n\n","category":"function"},{"location":"interface/#Toolips.span","page":"servables","title":"Toolips.span","text":"span(name::String; args ...) -> ::Component\n\n\n\nReturns the span Component with the key-word arguments provided in args as properties.\n\nexample\n\ncomp = span(\"newcomp\")\nwrite!(c, comp)\n\n\n\n\n\n","category":"function"},{"location":"interface/#Toolips.iframe","page":"servables","title":"Toolips.iframe","text":"iframe(name::String; args ...) -> ::Component\n\n\n\nReturns the iframe Component with the key-word arguments provided in args as properties.\n\nexample\n\ncomp = iframe(\"newcomp\")\nwrite!(c, comp)\n\n\n\n\n\n","category":"function"},{"location":"interface/#Toolips.svg","page":"servables","title":"Toolips.svg","text":"svg(name::String; args ...) -> ::Component\n\n\n\nReturns the svg Component with the key-word arguments provided in args as properties.\n\nexample\n\ncomp = svg(\"newcomp\")\nwrite!(c, comp)\n\n\n\n\n\n","category":"function"},{"location":"interface/#Toolips.element","page":"servables","title":"Toolips.element","text":"element(name::String; args ...) -> ::Component\n\n\n\nReturns the element Component with the key-word arguments provided in args as properties.\n\nexample\n\ncomp = element(\"newcomp\")\nwrite!(c, comp)\n\n\n\n\n\n","category":"function"},{"location":"interface/#Toolips.label","page":"servables","title":"Toolips.label","text":"label(name::String; args ...) -> ::Component\n\n\n\nReturns the label Component with the key-word arguments provided in args as properties.\n\nexample\n\nlbl = label(\"mylogo\", src = \"assets/logo.png\")\nwrite!(c, lbl)\n\n\n\n\n\n","category":"function"},{"location":"interface/#Toolips.script","page":"servables","title":"Toolips.script","text":"script(name::String; args ...) -> ::Component\n\n\n\nReturns the script Component with the key-word arguments provided in args as properties.\n\nexample\n\ncomp = script(\"newcomp\")\nwrite!(c, comp)\n\n\n\n\n\n","category":"function"},{"location":"interface/#Toolips.nav","page":"servables","title":"Toolips.nav","text":"nav(name::String; args ...) -> ::Component\n\n\n\nReturns the nav Component with the key-word arguments provided in args as properties.\n\nexample\n\ncomp = nav(\"newcomp\")\nwrite!(c, comp)\n\n\n\n\n\n","category":"function"},{"location":"interface/#Toolips.button","page":"servables","title":"Toolips.button","text":"button(name::String; args ...) -> ::Component\n\n\n\nReturns the button Component with the key-word arguments provided in args as properties.\n\nexample\n\ncomp = button(\"newcomp\")\nwrite!(c, comp)\n\n\n\n\n\n","category":"function"},{"location":"interface/#Toolips.form","page":"servables","title":"Toolips.form","text":"form(name::String; args ...) -> ::Component\n\n\n\nReturns the form Component with the key-word arguments provided in args as properties.\n\nexample\n\ncomp = form(\"newcomp\")\nwrite!(c, comp)\n\n\n\n\n\n","category":"function"},{"location":"interface/","page":"servables","title":"servables","text":"We can also compose components together using push!, and work with them using the following methods:","category":"page"},{"location":"interface/","page":"servables","title":"servables","text":"push!(::Component, ::Component ...)\nstyle!\ncomponents\nToolips.has_children\nToolips.properties!\ngetindex(::)","category":"page"},{"location":"interface/#Base.push!-Tuple{Component, Vararg{Component}}","page":"servables","title":"Base.push!","text":"Interface\n\npush!(s::Component, d::Component ...) -> ::Component\n\n\n\nAdds the child or children d to s.properties[:children]\n\nexample\n\nc = Component()\notherc = Component()\npush!(c, otherc)\n\n\n\n\n\n","category":"method"},{"location":"interface/#Toolips.style!","page":"servables","title":"Toolips.style!","text":"\n\n\n\n\n\n\n\nInterface\n\nstyle!(c::Servable, s::Style) -> _\n\n\n\nApplies the style to a servable.\n\nexample\n\nserv = p(\"wow\")\nmystyle = Style(\"mystyle\", color = \"lightblue\")\nstyle!(serv, mystyle)\n\n\n\n\n\nInterface\n\nstyle!(c::Servable, s::Pair ...) -> _\n\n\n\nApplies the style pairs to the servable's \"style\" property.\n\nexample\n\nmycomp = p(\"mycomp\")\nstyle!(mycomp, \"background-color\" => \"lightblue\", \"color\" => \"white\")\n\n\n\n\n\nInterface\n\nstyle!(::Style, ::Style) -> _\n\n\n\nCopies the properties from the second style into the first style.\n\nexample\n\nstyle1 = Style(\"firsts\")\nstyle2 = Style(\"seconds\")\nstyle1[\"color\"] = \"orange\"\nstyle!(style2, style1)\n\nstyle2[\"color\"]\n    \"orange\"\n\n\n\n\n\n","category":"function"},{"location":"interface/#Toolips.components","page":"servables","title":"Toolips.components","text":"Interface\n\ncomponents(cs::Servable ...) -> ::Vector{Servable}\n\n\n\nCreates a Vector{Servable} from multiple servables. This is useful because a vector of components could potentially become a Vector{Component}, for example and this is not the dispatch that is used universally across the package.\n\nexample\n\nc = Component()\nc2 = Component()\ncomponents(c, c2)\n    Vector{Servable}(Component(), Component())\n\n\n\n\n\n","category":"function"},{"location":"interface/#Toolips.has_children","page":"servables","title":"Toolips.has_children","text":"Interface\n\nhas_children(c::Component) -> ::Bool\n\n\n\nReturns true if the given component has children.\n\nexample\n\nc = Component()\notherc = Component()\npush!(c, otherc)\n\nhas_children(c)\n    true\nhas_children(otherc)\n    false\n\n\n\n\n\n","category":"function"},{"location":"interface/#Toolips.properties!","page":"servables","title":"Toolips.properties!","text":"Interface\n\nproperties!(c::Servable, s::Servable) -> _\n\n\n\nCopies properties from s,properties into c.properties.\n\nexample\n\ncomp = Component()\nothercomp = Component()\nothercomp[\"opacity\"] = \"100%\"\nproperties!(comp, othercomp)\n\ncomp[\"opacity\"]\n        100%\n\n\n\n\n\n","category":"function"},{"location":"interface/#style-components","page":"servables","title":"style components","text":"","category":"section"},{"location":"interface/","page":"servables","title":"servables","text":"Style components are change the style of a Component","category":"page"},{"location":"interface/","page":"servables","title":"servables","text":"StyleComponent","category":"page"},{"location":"interface/#Toolips.StyleComponent","page":"servables","title":"Toolips.StyleComponent","text":"abstract type StyleComponent <: Servable\n\nNo different from a normal Servable, simply an abstract type step for the interface to separate working with Animations and Styles.\n\nServable Consistencies\n\nServables can be written to a Connection via thier f() function and the\ninterface. They can also be indexed with strings or symbols to change properties\n##### Consistencies\n- f::Function - Function whose output to be written to http. Must take a single\npositonal argument of type ::Connection or ::AbstractConnection\n\n\n\n\n\n","category":"type"},{"location":"interface/","page":"servables","title":"servables","text":"Toolips.Style","category":"page"},{"location":"interface/#Toolips.Style","page":"servables","title":"Toolips.Style","text":"Style\n\nname::String\nf::Function\nproperties::Dict{Any, Any}\nextras::String Creates a style from attributes, can style a Component using the style! method.\n\nNames should be consistent with CSS names. For example, a default h1 style would be named \"h1\". A heading style for a specific class should be \"h1.myheading\"\n\nexample\n\nstyle = Style(\"p.mystyle\", color = \"blue\")\nstyle[\"opacity\"] = \"50%\"\ncomp = Component()\nstyle!(comp, style)\n\n\n\nfield info\n\nname::String - The name of the style. Should be consistent with CSS naming.\nf::Function - The function f, called by write! when writing to a Connection.\nproperties::Dict{Any, Any} - A dict of style attributes.\nextras::String - Extra components to be written along with the style. Usually\n\nthis is an animation.\n\nconstructors\n\nStyle(name::String; props ...)\n\n\n\n\n\n","category":"type"},{"location":"interface/","page":"servables","title":"servables","text":"The main style components are Animations and Styles.","category":"page"},{"location":"interface/","page":"servables","title":"servables","text":"Animation\nanimate!\ndelete_keyframe!","category":"page"},{"location":"interface/#Toolips.Animation","page":"servables","title":"Toolips.Animation","text":"Animation\n\nname::String\nkeyframes::Dict\nf::Function\ndelay::Float64\nlength::Float64\niterations::Integer An animation can be used to animate Styles with the animate! method. Animating\n\nis done by indexing by either percentage, or symbols, such as from and to.\n\nexample\n\nanim = Animation(\"myanim\")\nanim[:from] = \"opacity\" => \"0%\"\nanim[:to] = \"opacity\" => \"100%\"\nstyle = Style(\"example\")\nanimate!(style, anim)\n\n\n\nfield info\n\nname::String - The name of the animation.\nkeyframes::Dict - The keyframes that have been pushed so far.\nf::Function - The function called when writing to a Connection.\ndelay::Float64 - The delay before the animation begins.\nlength::Float64 - The amount of time the animation should play.\niterations::Integer - The number of times the animation should repeat. When\n\nset to 0 the animation will loop indefinitely.\n\nconstructors\n\nAnimation(name::String = \"animation\", delay::Float64 = 0.0,         length::Float64 = 5.2, iterations::Integer = 1)\n\n\n\n\n\n","category":"type"},{"location":"interface/#Toolips.animate!","page":"servables","title":"Toolips.animate!","text":"Interface\n\nanimate!(s::Style, a::Animation) -> _\n\n\n\nSets the Animation as a property of the style.\n\nexample\n\nanim = Animation(\"fade_in\")\nanim[:from] = \"opacity\" => \"0%\"\nanim[:to] = \"opacity\" => \"100%\"\n\nanimated_style = Style(\"example\")\nanimate!(animated_style, anim)\n\n\n\n\n\n","category":"function"},{"location":"interface/#Toolips.delete_keyframe!","page":"servables","title":"Toolips.delete_keyframe!","text":"Interface\n\ndelete_keyframe!(a::Animation, key::Int64) -> _\n\n\n\nDeletes a given keyframe from an animation by keyframe percentage.\n\nexample\n\nanim = Animation(\"\")\nanim[0] = \"opacity\" => \"0%\"\ndelete_keyframe!(anim, 0)\n\n\n\n\n\nInterface\n\ndelete_keyframe!(a::Animation, key::Symbol) -> _\n\n\n\nDeletes a given keyframe from an animation by keyframe name.\n\nexample\n\nanim = Animation(\"\")\nanim[:to] = \"opacity\" => \"0%\"\ndelete_keyframe!(anim, :to)\n\n\n\n\n\n","category":"function"},{"location":"interface/","page":"servables","title":"servables","text":"Animating and property adjustment is done with indexing.","category":"page"},{"location":"interface/","page":"servables","title":"servables","text":"setindex!(::Animation, ::Pair, ::Symbol)\nsetindex!(::Animation, ::Pair, ::Int64)","category":"page"},{"location":"interface/#Base.setindex!-Tuple{Animation, Pair, Symbol}","page":"servables","title":"Base.setindex!","text":"Interface\n\nsetindex!(anim::Animation, set::Pair, n::Symbol) -> _\n\n\n\nSets the animation at the corresponding key-word's position. Usually these are :to and :from.\n\nexample\n\na = Animation(\"world\")\na[:to] = \"opacity\" => \"0%\"\n\n\n\n\n\n","category":"method"},{"location":"interface/#Base.setindex!-Tuple{Animation, Pair, Int64}","page":"servables","title":"Base.setindex!","text":"Interface\n\nsetindex!(anim::Animation, set::Pair, n::Int64) -> _\n\n\n\nSets the animation at the percentage of the Int64 to modify the properties of pair.\n\nexample\n\na = Animation(\"world\")\na[0] = \"opacity\" => \"0%\"\n\n\n\n\n\n","category":"method"},{"location":"interface/#other-servables","page":"servables","title":"other servables","text":"","category":"section"},{"location":"interface/","page":"servables","title":"servables","text":"The file Servable, as you might expect, serves a file via a directory.","category":"page"},{"location":"interface/","page":"servables","title":"servables","text":"File","category":"page"},{"location":"interface/#Toolips.File","page":"servables","title":"Toolips.File","text":"File <: Servable\n\ndir::String f::Function Serves a file into a Connection.\n\nexample\n\nf = File(\"hello.txt\")\nr = route(\"/\") do c\n    write!(c, f)\nend\n\n\n\nfield info\n\ndir::String - The directory of a file to serve.\nf::Function - Function whose output to be written to http().\n\n\n\nconstructors\n\nFile(dir::String)\n\n\n\n\n\n","category":"type"},{"location":"interface/","page":"servables","title":"servables","text":"Servables are also incredibly easy to write, and part of the beauty of toolips is just how easy it is to create these kinds of extensions in toolips!","category":"page"},{"location":"developer_api/#advanced-usage","page":"extending toolips","title":"advanced usage","text":"","category":"section"},{"location":"developer_api/","page":"extending toolips","title":"extending toolips","text":"Welcome to the Toolips developer API. This section describes making toolips extensions as well as","category":"page"},{"location":"developer_api/#creating-servables","page":"extending toolips","title":"creating servables","text":"","category":"section"},{"location":"developer_api/","page":"extending toolips","title":"extending toolips","text":"Servables are probably the most approachable type to make for your first extension. Servable extensions work by simply making a sub-type of Servable. For example, the Component's source code:","category":"page"},{"location":"developer_api/","page":"extending toolips","title":"extending toolips","text":"function Component(name::String = \"\", tag::String = \"\",\n     properties::Dict = Dict{Any, Any}())\n     push!(properties, :children => Vector{Servable}())\n     extras = Vector{Servable}()\n     f(c::AbstractConnection) = begin\n         open_tag::String = \"<$tag id = $name \"\n         text::String = \"\"\n         write!(c, open_tag)\n         for property in keys(properties)\n             special_keys = [:text, :children]\n             if ~(property in special_keys)\n                 prop::String = string(properties[property])\n                 propkey::String = string(property)\n                 write!(c, \" $propkey = $prop \")\n             else\n                 if property == :text\n                     text = properties[property]\n                 end\n             end\n         end\n         write!(c, \">\")\n         if length(properties[:children]) > 0\n             write!(c, properties[:children])\n        end\n        write!(c, \"$text</$tag>\")\n        write!(c, extras)\n     end\n     new(name, f, properties, extras, tag)::Component\nend","category":"page"},{"location":"developer_api/","page":"extending toolips","title":"extending toolips","text":"The Interface portion of this module is actually built as a Toolips extension itself. Anyway, as you can see, the function f is provided. This is the one consistent field every servable must have. In that field you are able to write to the document with text how you normally would. That being said, Servable extensions can be used simply to generate one portion of your website while holding some information in a constructor. As soon as it is created, it is immediately dispatched to methods like write!, etc. Here is another, more simple example where we write a header.","category":"page"},{"location":"developer_api/","page":"extending toolips","title":"extending toolips","text":"import Toolips: Servable\nmutable struct MyHeader <: Servable\n    f::Function\n    cs::Vector{Servable}\n    function MyHeader(name = \"Hello World\")\n        anim = Animation(\"fade_in\")\n        div_s = Style(\"div.myheaderstyle\", color = \"lightblue\")\n        header_div = divider(\"header_div\", align = \"center\")\n        heading = h(1, \"Hello, welcome!\", align = \"center\")\n        style!(heading, \"color\" => \"white\")\n        push!(header_div, heading)\n        animate!(div_s, anim)\n        cs = components(div_s, header_div)\n        f(c::Connection) = write!(c, cs)\n        new(f, cs)\n    end\nend","category":"page"},{"location":"developer_api/","page":"extending toolips","title":"extending toolips","text":"Is this the best way to serve your websites? It could be. This is somewhat of a manipulation to the paradigm of Toolips, but also allows for the creation of some  other extensions.","category":"page"},{"location":"developer_api/","page":"extending toolips","title":"extending toolips","text":"Toolips.Servable","category":"page"},{"location":"developer_api/#Toolips.Servable","page":"extending toolips","title":"Toolips.Servable","text":"abstract type Servable\n\nServables can be written to a Connection via thier f() function and the interface. They can also be indexed with strings or symbols to change properties\n\nConsistencies\n\nf::Function - Function whose output to be written to http. Must take a single\n\npositonal argument of type ::Connection or ::AbstractConnection\n\n\n\n\n\n","category":"type"},{"location":"developer_api/#creating-connection-extensions","page":"extending toolips","title":"creating connection extensions","text":"","category":"section"},{"location":"developer_api/","page":"extending toolips","title":"extending toolips","text":"Toolips.AbstractConnection","category":"page"},{"location":"developer_api/#Toolips.AbstractConnection","page":"extending toolips","title":"Toolips.AbstractConnection","text":"abstract type AbstractConnection\n\nConnections are passed through function routes and can have Servables written     to it.\n\nConsistencies\n\nroutes::Dict - A {String, Function} dictionary that the server references to\n\ndirect incoming connections.\n\nhttp::Any - Usually an HTTP.Stream, however can be anything that is binded to\n\nthe Base.write method.\n\nextensions::Dict - A {Symbol, ServerExtension} dictionary that can be used to\n\naccess ServerExtensions.\n\n\n\n\n\n","category":"type"},{"location":"developer_api/#creating-server-extensions","page":"extending toolips","title":"creating server extensions","text":"","category":"section"},{"location":"developer_api/","page":"extending toolips","title":"extending toolips","text":"Toolips.ServerExtension","category":"page"},{"location":"developer_api/#Toolips.ServerExtension","page":"extending toolips","title":"Toolips.ServerExtension","text":"abstract type ServerExtension\n\nServer extensions are loaded into the server on startup, and can have a few different abilities according to their type field's value. This value can be either a Symbol or a Vector of Symbols.\n\nConsistencies\n\ntype::T where T == Vector{Symbol}  || T == Symbol. The type can be :routing,\n\n:func, :connection, or any combination inside of a Vector{Symbol}. :routing ServerExtensions must have an f() function that takes two dictionaries; e.g. f(r::Dict{String, Function}, e::Dict{Symbol, ServerExtension}) The first Dict is the dictionary of routes, the second is the dictionary of server extensions. :func server extensions will be ran everytime the server is routed. They will need to have the same f function, but taking a single argument as a connection.     Lastly, :connection extensions are simply pushed to the connection.\n\n\n\n\n\n","category":"type"},{"location":"developer_api/#toolips-internals","page":"extending toolips","title":"toolips internals","text":"","category":"section"},{"location":"developer_api/","page":"extending toolips","title":"extending toolips","text":"If you're looking at the internals, you are probably good enough at reading documentation... Here are the doc-strings, my friend. Thank you for contributing.","category":"page"},{"location":"developer_api/","page":"extending toolips","title":"extending toolips","text":"Toolips.write(::SpoofStream, ::Any)\nToolips.write(::SpoofStream, ::Servable)\nToolips.create_serverdeps\nToolips.serverfuncdefs\nToolips._start\nToolips.generate_router\nToolips._log\nToolips.string\nToolips.SpoofConnection\nToolips.SpoofStream\nToolips.route_from_dir\nToolips.show(::Base.TTY, ::Component)\nToolips.show(::Component)\nToolips.show_log\nToolips.@L_str\nToolips.has_extension(d::Dict, t::Type)\nToolips.argsplit\nToolips.string(::Vector{UInt8})\nToolips.showchildren","category":"page"},{"location":"developer_api/#Base.write-Tuple{SpoofStream, Any}","page":"extending toolips","title":"Base.write","text":"Internals\n\nwrite(s::SpoofStream, e::Any) -> _\n\n\n\nA binding to Base.write that allows one to write to SpoofStream.text.\n\nexample\n\ns = SpoofStream()\nwrite(s, \"hi\")\nprintln(s.text)\n    hi\n\n\n\n\n\n","category":"method"},{"location":"developer_api/#Base.write-Tuple{SpoofStream, Servable}","page":"extending toolips","title":"Base.write","text":"Internals\n\nwrite(s::SpoofStream, e::Servable) -> _\n\n\n\nA binding to Base.write that allows one to write a Servable to SpoofStream.text.\n\nexample\n\ns = SpoofStream()\nwrite(s, p(\"hello\"))\nprintln(s.text)\n    <p id = \"hello\"></p>\n\n\n\n\n\n","category":"method"},{"location":"developer_api/#Toolips.create_serverdeps","page":"extending toolips","title":"Toolips.create_serverdeps","text":"Internals\n\ncreate_serverdeps(name::String, inc::String) -> _\n\n\n\nCreates the essential portions of the webapp file structure, where name is the project's name and inc is any extensions or strings to incorporate at the top of the file.\n\nexample\n\ncreate_serverdeps(\"ToolipsApp\")\n\n\n\n\n\n","category":"function"},{"location":"developer_api/#Toolips.serverfuncdefs","page":"extending toolips","title":"Toolips.serverfuncdefs","text":"Core\n\nserverfuncdefs(::AbstractVector, ::String, ::Integer,\n\n::Dict) -> (::Function, ::Function, ::Function)\n\nThis method is used internally by a constructor to generate the functions add, start, and remove for the ServerTemplate.\n\nexample\n\n\n\n\n\n","category":"function"},{"location":"developer_api/#Toolips._start","page":"extending toolips","title":"Toolips._start","text":"Core - Internals\n\n_start(routes::AbstractVector, ip::String, port::Integer,\n\nextensions::Dict, c::Type) -> ::WebServer\n\nThis is an internal function for the ServerTemplate. This function is binded to     the ServerTemplate.start field.\n\nexample\n\nst = ServerTemplate()\nst.start()\n\n\n\n\n\n","category":"function"},{"location":"developer_api/#Toolips.generate_router","page":"extending toolips","title":"Toolips.generate_router","text":"Core - Internals\n\ngenerate_router(routes::AbstractVector, server::Any, extensions::Dict,\n\n        conn::Type)\n\n\n\nThis method is used internally by the _start method. It returns a closure function that both routes and calls functions.\n\nexample\n\nserver = Sockets.listen(Sockets.InetAddr(parse(IPAddr, ip), port))\nif has_extension(extensions, Logger)\n    extensions[Logger].log(1,\n     \"Toolips Server starting on port \" * string(port))\nend\nroutefunc, rdct, extensions = generate_router(routes, server, extensions,\n                                                Connection)\n@async HTTP.listen(routefunc, ip, port, server = server)\n\n\n\n\n\n","category":"function"},{"location":"developer_api/#Toolips._log","page":"extending toolips","title":"Toolips._log","text":"Extensions\n\n_log(level::Int64, message::String, levels::Dict, out::String) -> _\n\n\n\nBinded call for the field log() inside of Logger(). See ?(Logger) for more     details on the field log. All arguments are fields of that type. Return is a     printout into the REPL as well as an append to the log file, provided by the     out URI. â€“â€“â€“â€“â€“â€“â€“â€“â€“\n\nexample (Closure from Logger)\n\nlog(level::Int64, message::String) = _log(level, message, levels, out)\nlog(message::String) = _log(1, message, levels, out)\n\n\n\n\n\nExtensions\n\n_log(http::HTTP.Stream, message::String) -> _\n\n\n\nBinded call for the field log() inside of Logger(). This will log both to the     JavaScript/HTML console. â€“â€“â€“â€“â€“â€“â€“â€“â€“\n\nexample (Closure from Logger)\n\nlog(http::HTTP.Stream, message::String) = _log(http, message)\n\n\n\n\n\n","category":"function"},{"location":"developer_api/#Base.string","page":"extending toolips","title":"Base.string","text":"Internals\n\nstring(r::Vector{UInt8}) -> ::String\n\n\n\nTurns a vector of UInt8s into a string.\n\n\n\n\n\nInterface\n\nstring(c::Component) -> ::String\n\n\n\nShows c as a string representation of itself.\n\nexample\n\nc = divider(\"example\", align = \"center\")\nstring(c)\n    \"divider: align = center\"\n\n\n\n\n\n","category":"function"},{"location":"developer_api/#Toolips.SpoofConnection","page":"extending toolips","title":"Toolips.SpoofConnection","text":"SpoofConnection <: AbstractConnection\n\nroutes::Dict\nhttp::SpoofStream\nextensions::Dict Builds a fake connection with a SpoofStream. Useful if you want to write\n\na Servable without a server.\n\nexample\n\nfakec = SpoofConnection()\nservable = Component()\n# write!(::AbstractConnection, ::Servable):\nwrite!(fakec, servable)\n\n\n\nfield info\n\nroutes::Dict - A dictionary of routes, usually left empty.\nhttp::SpoofStream - A fake http stream that instead writes output to a string.\nextensions::Dict - A dictionary of extensions, usually empty.\n\n\n\nconstructors\n\nSpoofStream(r::Dict, http::SpoofStream, extensions::Dict)\nSpoofStream()\n\n\n\n\n\n","category":"type"},{"location":"developer_api/#Toolips.SpoofStream","page":"extending toolips","title":"Toolips.SpoofStream","text":"SpoofStream\n\ntext::String The SpoofStream allows us to fake a connection by building a SpoofConnection\n\nwhich will write to the SpoofStream.text field whenever write! is called. This is useful for testing, or just writing servables into a string.\n\nexample\n\nstream = SpoofStream()\nwrite(stream, \"hello!\")\nprintln(stream.text)\n\n    hello!\nconn = SpoofConnection()\nservab = Component()\nwrite!(conn, servab)\n\n\n\nfield info\n\ntext::String - The text written to the stream.\n\n\n\nconstructors\n\nSpoofStream()\n\n\n\n\n\n","category":"type"},{"location":"developer_api/#Toolips.route_from_dir","page":"extending toolips","title":"Toolips.route_from_dir","text":"Extensions\n\nroutefromdir(dir::String) -> ::Vector{String}\n\n\n\nRecursively appends filenames for a directory AND all subsequent directories.\n\nexample\n\nx::Vector{String} = route_from_dir(\"mypath\")\n\n\n\n\n\n","category":"function"},{"location":"developer_api/#Base.show-Tuple{Base.TTY, Component}","page":"extending toolips","title":"Base.show","text":"Interface\n\nshow(t::Base.TTY, x::Component) -> _\n\n\n\nShows a component as markdown in a terminal.\n\nexample\n\n# In the terminal, elsewhere the component will show as HTML.\nshow(x)\n\n\n\n\n\n","category":"method"},{"location":"developer_api/#Base.show-Tuple{Component}","page":"extending toolips","title":"Base.show","text":"Interface\n\nshow(x::Component) -> _\n\n\n\nShows a component as HTML.\n\nexample\n\nshow(x)\n\n\n\n\n\n","category":"method"},{"location":"developer_api/#Toolips.show_log","page":"extending toolips","title":"Toolips.show_log","text":"Extensions\n\nshow_log(level::Int64, message::String, levels::Dict{Any, Crayon},\n\n            prefix::String, time::Any)\n\n\n\nPrints a log to the screen.\n\nexample\n\nshow_log(1, \"hello!\", levels, \"toolips> \", now()\n\n[2022:05:23:22:01] toolips> hello!\n\n\n\n\n\n","category":"function"},{"location":"developer_api/#Toolips.@L_str","page":"extending toolips","title":"Toolips.@L_str","text":"Interface\n\nL_str(s::String) -> ::String\n\n\n\nCreates a literal string\n\nexample\n\nx = 5\nL\"dollar_signx\" # pretend dollar_sign is a dollar sign.\n\n\n\n\n\n","category":"macro"},{"location":"developer_api/#Toolips.has_extension-Tuple{Dict, Type}","page":"extending toolips","title":"Toolips.has_extension","text":"Internals\n\nhas_extension(d::Dict, t::Type) -> ::Bool\n\n\n\nChecks if d has an extension of type t.\n\nexample\n\nif has_extension(d, Logger)\n    d[:Logger].log(\"it has a logger, I think.\")\nend\n\n\n\n\n\n","category":"method"},{"location":"developer_api/#Toolips.argsplit","page":"extending toolips","title":"Toolips.argsplit","text":"Internals\n\nargsplit(args::Vector{AbstractString}) -> ::Dict{Symbol, Any}\n\n\n\nUsed by the getargs method to parse GET arguments into a Dict.\n\nexample\n\nargsplit([\"c=5\", \"b=8\"])\n    Dict(:c => 5, :b => 8)\n\n\n\n\n\n","category":"function"},{"location":"developer_api/#Base.string-Tuple{Vector{UInt8}}","page":"extending toolips","title":"Base.string","text":"Internals\n\nstring(r::Vector{UInt8}) -> ::String\n\n\n\nTurns a vector of UInt8s into a string.\n\n\n\n\n\n","category":"method"},{"location":"developer_api/#Toolips.showchildren","page":"extending toolips","title":"Toolips.showchildren","text":"Internals\n\nshowchildren(x::Component) -> ::String\n\n\n\nGet the children of x as a markdown string.\n\nexample\n\nc = divider(\"example\")\nchild = p(\"mychild\")\npush!(c, child)\ns = showchildren(c)\nprintln(s)\n\"##### children\n|-- mychild\n\n\n\n\n\n","category":"function"},{"location":"toolips_session/#toolips-session-extension","page":"sessions","title":"toolips session extension","text":"","category":"section"},{"location":"toolips_session/","page":"sessions","title":"sessions","text":"The ToolipsSession extension is  loaded into apps by default whenever the new_webapp() method is used to create their files, along with the Files extension from the Toolips core (?(Files)).","category":"page"},{"location":"toolips_session/","page":"sessions","title":"sessions","text":"Modules = [ToolipsSession]","category":"page"},{"location":"toolips_session/#ToolipsSession.ToolipsSession","page":"sessions","title":"ToolipsSession.ToolipsSession","text":"Created in June, 2022 by chifi - an open source software dynasty. by team toolips This software is MIT-licensed.\n\nToolipsSession\n\nExtension for:\n\nToolips This module provides the capability to make web-pages interactive by simply\n\nadding the Session extension to your ServerTemplate before starting. There are also methods contained for modifying Servables.\n\nModule Composition\n\nToolipsSession\n\n\n\n\n\n","category":"module"},{"location":"toolips_session/#ToolipsSession.ComponentModifier","page":"sessions","title":"ToolipsSession.ComponentModifier","text":"Name\n\ntext::String Description\n\nexample\n\n\n\n\n\nfield info\n\n\n\nconstructors\n\n\n\n\n\n","category":"type"},{"location":"toolips_session/#ToolipsSession.Session","page":"sessions","title":"ToolipsSession.Session","text":"Session\n\ntype::Vector{Symbol}\nf::Function\nactive_routes::Vector{String}\nevents::Dict{String, Pair{String, Function}}\niptable::Dict{String, Dates.DateTime}\ntimeout::Integer Provides session capabilities and full-stack interactivity to a toolips server.\n\nexample\n\nexts = [Session()]\nst = ServerTemplate(extensions = exts)\nserver = st.start()\n\nroute!(server, \"/\") do c::Connection\n    myp = p(\"myp\", text = \"welcome to my site\")\n    on(c, myp, \"click\") do cm::ComponentModifier\n        if cm[myp][:text] == \"welcome to my site\"\n            set_text!(cm, myp, \"unwelcome to my site\")\n        else\n            set_text!(cm, myp, \"welcome to my site\")\n        end\n    end\n    write!(c, myp)\nend\n\n\n\nfield info\n\n\n\nconstructors\n\n\n\n\n\n","category":"type"},{"location":"toolips_session/#ToolipsSession.TimedTrigger","page":"sessions","title":"ToolipsSession.TimedTrigger","text":"\n\n\n\n","category":"type"},{"location":"toolips_session/#Toolips.kill!-Tuple{Connection}","page":"sessions","title":"Toolips.kill!","text":"\n\n\n\n","category":"method"},{"location":"toolips_session/#Toolips.style!-Tuple{ComponentModifier, Servable, Vararg{Pair{String, String}}}","page":"sessions","title":"Toolips.style!","text":"\n\n\n\n","category":"method"},{"location":"toolips_session/#Toolips.style!-Tuple{ComponentModifier, Servable, Vector{Pair{String, String}}}","page":"sessions","title":"Toolips.style!","text":"\n\n\n\n","category":"method"},{"location":"toolips_session/#ToolipsSession.document_linker-Tuple{Connection}","page":"sessions","title":"ToolipsSession.document_linker","text":"document_linker(c::Connection) -> _\n\n\n\n\n\n","category":"method"},{"location":"toolips_session/#ToolipsSession.gen_ref-Tuple{}","page":"sessions","title":"ToolipsSession.gen_ref","text":"Session\n\ngen_ref() -> ::String\n\n\n\nCreates a random string of 16 characters. This is used to map connections to specific events by the session.\n\nexample\n\ngen_ref()\n\"jfuR2wgprielweh3\"\n\n\n\n\n\n","category":"method"},{"location":"toolips_session/#ToolipsSession.get_text-Tuple{ComponentModifier, Component}","page":"sessions","title":"ToolipsSession.get_text","text":"\n\n\n\n","category":"method"},{"location":"toolips_session/#ToolipsSession.modify!-Tuple{ComponentModifier, Servable, Pair}","page":"sessions","title":"ToolipsSession.modify!","text":"\n\n\n\n","category":"method"},{"location":"toolips_session/#ToolipsSession.modify!-Tuple{ComponentModifier, Servable, Vararg{Pair}}","page":"sessions","title":"ToolipsSession.modify!","text":"\n\n\n\n","category":"method"},{"location":"toolips_session/#ToolipsSession.modify!-Tuple{ComponentModifier, Servable, Vector{Pair{String, String}}}","page":"sessions","title":"ToolipsSession.modify!","text":"\n\n\n\n","category":"method"},{"location":"toolips_session/#ToolipsSession.observe!-Tuple{Function, Connection, Integer}","page":"sessions","title":"ToolipsSession.observe!","text":"\n\n\n\n","category":"method"},{"location":"toolips_session/#ToolipsSession.on-Tuple{Function, Connection, Component, AbstractString}","page":"sessions","title":"ToolipsSession.on","text":"\n\n\n\n","category":"method"},{"location":"toolips_session/#ToolipsSession.remove!-Tuple{Connection, AbstractString, Servable}","page":"sessions","title":"ToolipsSession.remove!","text":"\n\n\n\n","category":"method"},{"location":"#toolips-docs","page":"toolips","title":"toolips docs","text":"","category":"section"},{"location":"#a-manic-web-development-framework","page":"toolips","title":"a manic web-development framework","text":"","category":"section"},{"location":"","page":"toolips","title":"toolips","text":"Toolips.jl is a reactive. full-stack, modular and extendable web-development framework written in pure Julia.","category":"page"},{"location":"#tutorials","page":"toolips","title":"tutorials","text":"","category":"section"},{"location":"","page":"toolips","title":"toolips","text":"Basics - Creating an API\nBasics - Building a static site\nIntermediate - Building Your First WebApp\nAdvanced - Creating a ServerExtension","category":"page"},{"location":"#curated-projects","page":"toolips","title":"curated projects","text":"","category":"section"},{"location":"","page":"toolips","title":"toolips","text":"Below are some curated and deployed toolips apps and toolips extensions that can be used as examples or loaded as a server extension to look into.","category":"page"},{"location":"#modules","page":"toolips","title":"modules","text":"","category":"section"},{"location":"#sites","page":"toolips","title":"sites","text":"","category":"section"},{"location":"","page":"toolips","title":"toolips","text":"EmsComputer.jl - ems computer\nToolipsApp.jl - toolips app","category":"page"},{"location":"#server-extensions","page":"toolips","title":"server extensions","text":"","category":"section"},{"location":"","page":"toolips","title":"toolips","text":"ToolipsModifier.jl - Reactive Components.\nToolipsRemote.jl - Allows remote management of a Toolips server via a","category":"page"},{"location":"","page":"toolips","title":"toolips","text":"regular HTTP request.","category":"page"},{"location":"","page":"toolips","title":"toolips","text":"ToolipsDefaults.jl - More style components, and style default methods.","category":"page"},{"location":"#servables","page":"toolips","title":"servables","text":"","category":"section"},{"location":"","page":"toolips","title":"toolips","text":"ToolipsDefaults.jl - More style components, and style default methods.\nToolipsCanvas.jl - Interact with the Canvas element via script.","category":"page"},{"location":"","page":"toolips","title":"toolips","text":"Toolips","category":"page"},{"location":"#Toolips","page":"toolips","title":"Toolips","text":"Created in February, 2022 by chifi - an open source software dynasty. by team toolips This software is MIT-licensed.\n\nToolips\n\nToolips.jl is a fast, asynchronous, low-memory, full-stack, and reactive web-development framework always written in pure Julia.\n\nModule Composition\n\nToolips\n\n\n\n\n\n","category":"module"},{"location":"projects/#projects","page":"projects","title":"projects","text":"","category":"section"},{"location":"projects/","page":"projects","title":"projects","text":"Projects in Toolips are easy to start. You can either choose to create a project directory structure, or optionally; you can create an entire server inside of your REPL!","category":"page"},{"location":"projects/#creating-a-project","page":"projects","title":"creating a project","text":"","category":"section"},{"location":"projects/","page":"projects","title":"projects","text":"Toolips projects are created using the newapp and newwebapp methods respectively. newapp will create a simple project and newwebapp will create a full-stack web-app.","category":"page"},{"location":"projects/","page":"projects","title":"projects","text":"Toolips.new_app","category":"page"},{"location":"projects/#Toolips.new_app","page":"projects","title":"Toolips.new_app","text":"Core\n\nnew_app(::String) -> _\n\n\n\nCreates a minimalistic app, usually used for creating APIs and endpoints.\n\nexample\n\nusing Toolips\nToolips.new_app(\"ToolipsApp\")\n\n\n\n\n\n","category":"function"},{"location":"projects/","page":"projects","title":"projects","text":"Toolips.new_webapp","category":"page"},{"location":"projects/#Toolips.new_webapp","page":"projects","title":"Toolips.new_webapp","text":"Core\n\nnew_webapp(::String) -> _\n\n\n\nCreates a fully-featured Toolips web-app. Adds ToolipsSession, ideal for full-stack web-sites.\n\nexample\n\nusing Toolips\nToolips.new_webapp(\"ToolipsApp\")\n\n\n\n\n\n","category":"function"},{"location":"projects/#a-repl-crash-course","page":"projects","title":"a repl crash course","text":"","category":"section"},{"location":"projects/","page":"projects","title":"projects","text":"After a server is running, Toolips has an interactive level that allows you to introspect and modify server attributes via the WebServer type. If you start a project with new web-app or new-app, then your WebServer type on your new server will automatically become (project-name)Server. For example, a ToolipsTutorial WebServer would be named ToolipsTutorialServer by default. Let's create a new project and get started with the toolips command-line interface.","category":"page"},{"location":"projects/","page":"projects","title":"projects","text":"using Toolips\nToolips.new_app(\"MyApp\")\n\njulia> Toolips.new_app(\"MyApp\")\n  Generating  project MyApp:\n    MyApp/Project.toml\n    MyApp/src/MyApp.jl\n....","category":"page"},{"location":"projects/","page":"projects","title":"projects","text":"Now we will cd into our new project directory, and activate dev.jl.","category":"page"},{"location":"projects/","page":"projects","title":"projects","text":"shell> cd MyApp\n/home/emmac/dev/toolips/MyApp\njulia> include(\"dev.jl\")\n  Activating project at `~/dev/toolips/MyApp`\n[2022:06:19:15:37]: ðŸŒ· toolips> Toolips Server starting on port 8000\n[2022:06:19:15:37]: ðŸŒ· toolips> Successfully started server on port 8000\n[2022:06:19:15:37]: ðŸŒ· toolips> You may visit it now at http://127.0.0.1:8000","category":"page"},{"location":"projects/","page":"projects","title":"projects","text":"Activating this will give us the new variable MyAppServer. To start, we can view our routes and extensions by using the methods under those same names:","category":"page"},{"location":"projects/","page":"projects","title":"projects","text":"?(routes(ws::WebServer))\n\njulia> routes(MyAppServer)\nDict{String, Function} with 2 entries:\n  \"404\" => #1\n  \"/\"   => home\n\n  julia> Toolips.extensions(MyAppServer)\n Dict{Symbol, Logger} with 1 entry:\n   :Logger => Logger(:connection, \"/home/emmac/dev/toolips/MyApp/logs/log.txt\", Dict{Any, Crayons.Crayon}(4=>\\e[31;1m, 2=>\\e[93m, :message_crayon=>\\e[94;1m, 3=>\\e[33;1m, 1=>\\e[96m, :time_crayon=>","category":"page"},{"location":"projects/","page":"projects","title":"projects","text":"We can also reroute the server's routes with the route! method:","category":"page"},{"location":"projects/","page":"projects","title":"projects","text":"route!(MyAppServer, \"/\") do c::Connection\n    c[:Logger].log(\"Wow!\")\nend","category":"page"},{"location":"projects/","page":"projects","title":"projects","text":"We can index extensions with a Symbol, and index routes with a String.","category":"page"},{"location":"projects/","page":"projects","title":"projects","text":"c[\"/\"]\n    home\nc[:Logger]\n    Logger( .....  )","category":"page"},{"location":"projects/","page":"projects","title":"projects","text":"Lastly, we can kill the server using kill!","category":"page"},{"location":"projects/","page":"projects","title":"projects","text":"kill!(MyAppServer)","category":"page"},{"location":"projects/#project-walkthrough","page":"projects","title":"project walkthrough","text":"","category":"section"},{"location":"projects/","page":"projects","title":"projects","text":"Toolips projects  work just like any other Julia project. There is no random silliness going on here â€“ no need to source anything with Bash, merely call Julia. After running newapp or newwebapp, you should be greeted with a new directory named after your project name.","category":"page"},{"location":"projects/","page":"projects","title":"projects","text":"using Pkg; Pkg.add(\"Toolips\")\nusing Toolips\nToolips.new_webapp(\"ToolipsTutorial\")","category":"page"},{"location":"projects/","page":"projects","title":"projects","text":"cd ToolipsTutorial\n~/dev/ToolipsTutorial\n\ntree .\n[.]\nâ”œâ”€â”€ dev.jl\nâ”œâ”€â”€ prod.jl\nâ”œâ”€â”€ Manifest.toml\nâ”œâ”€â”€ Project.toml\nâ”œâ”€â”€ [logs]\nâ”‚Â Â  â””â”€â”€ log.txt\nâ”œâ”€â”€ [public]\nâ””â”€â”€ [src]\n    â””â”€â”€ ToolipsTutorial.jl\n\n3 directories, 6 files\n","category":"page"},{"location":"projects/","page":"projects","title":"projects","text":"The directory structure is that of a typical Julia project â€“ albeit with a few extra little files and folders. The source code that creates our websites is contained within the src directory. A Logger comes loaded as a default extension, although we could remove it if we really wanted to, or likewise â€“ create our own Logger and load it as an extension â€“ which is pretty much what makes toolips great. The Logger by default will log to the logs directory. The public directory contains any files we want to be served automatically by the Files ServerExtension. This directory will be missing if you decide to utilize the new_app method. The other two things that are not Julia defaults are the files dev.jl and prod.jl. These are environment files, they store environmental variables to be sourced above the module in Main. Let's take a look:","category":"page"},{"location":"projects/#dev.jl","page":"projects","title":"dev.jl","text":"","category":"section"},{"location":"projects/","page":"projects","title":"projects","text":"#==\ndev.jl is an environment file. This file loads and starts servers, and\ndefines environmental variables, setting the scope a lexical step higher\nwith modularity.\n==#\nusing Pkg; Pkg.activate(\".\")\nusing Toolips\nusing Revise\nusing ToolipsModifier\nusing ToolipsTutorial\n\nIP = \"127.0.0.1\"\nPORT = 8000\n#==\nExtension description\n:logger -> Logs messages into both a file folder and the terminal.\n:public -> Routes the files from the public directory.\n:mod -> ToolipsModifier; allows us to make Servables reactive. See ?(on)\n==#\nextensions = Dict(:logger => Logger(), :public => Files(\"public\"),\n:mod => Modifier())\nToolipsTutorialServer = ToolipsTutorial.start(IP, PORT, extensions)","category":"page"},{"location":"projects/","page":"projects","title":"projects","text":"Firstly, dev.jl activates the project environment with Pkg. Next, we load all of the dependencies. The first one is the most obvious; you are reading the documentation for it. The second one is Revise. Revise.jl allows us to update our modules while they are loaded into main. This just makes rerouting easier, as you can modify the text file, save it, update the routes, and then your new website is up with no downtime. No worries, I will be showing how this is done in no time. First though, we will also consider the extensions section. I have been kind enough to leave a little note here,","category":"page"},{"location":"projects/","page":"projects","title":"projects","text":"Extension description\n:logger -> Logs messages into both a file folder and the terminal.\n:public -> Routes the files from the public directory.\n:mod -> ToolipsModifier; allows us to make Servables reactive. See ?(on)","category":"page"},{"location":"projects/","page":"projects","title":"projects","text":"This describes what each extension does. Of course, all the effort it takes to add more is merely adding them via Pkg and adding them to this dictionary. We are going to include this file in order to start the server. We would include prod.jl if we wanted to start a production server, which is a very similar file in content, jut missing the Revise.jl First, let us take a look at the source file.","category":"page"},{"location":"projects/#src.jl","page":"projects","title":"src.jl","text":"","category":"section"},{"location":"projects/","page":"projects","title":"projects","text":"module ToolipsTutorial\nusing Toolips\nusing ToolipsModifier\n\nfunction home(c::Connection)\n    write!(c, p(\"helloworld\", text = \"hello world!\"))\nend\n\nfourofour = route(\"404\") do c\n    write!(c, p(\"404message\", text = \"404, not found!\"))\nend\n\n\"\"\"\nstart()\n\"\"\"\nfunction start(IP::String = \"127.0.0.1\", PORT::Integer = 8000,\n    extensions::Dict = Dict(:logger => Logger()))\n    rs = routes(route(\"/\", home), fourofour)\n    server = ServerTemplate(IP, PORT, rs, extensions = extensions)\n    server.start()\nend\n\nend # - module","category":"page"},{"location":"projects/#start","page":"projects","title":"start","text":"","category":"section"},{"location":"projects/","page":"projects","title":"projects","text":"This file will likely look a bit different in the future, with a bit more documentation, and maybe a more illustrious default project, but do not fret â€“ the names will all be the same and the file similar enough! The start function is probably the most important here. This function constructs our Routes, makes a ServerTemplate and then runs ServerTemplate.start(), returning a WebServer. Back up in dev.jl we see that this is aptly named \"projectnameServer\"","category":"page"},{"location":"projects/","page":"projects","title":"projects","text":"extensions = Dict(:logger => Logger(), :public => Files(\"public\"),\n:mod => Modifier())\nToolipsTutorialServer = ToolipsTutorial.start(IP, PORT, extensions)","category":"page"},{"location":"projects/#home","page":"projects","title":"home","text":"","category":"section"},{"location":"projects/","page":"projects","title":"projects","text":"function home(c::Connection)\n    write!(c, p(\"helloworld\", text = \"hello world!\"))\nend","category":"page"},{"location":"projects/","page":"projects","title":"projects","text":"The home function is a function built to be routed to. We can tell this is the ] case because it takes a Connection as its only argument. This is one method of making a route. Inside the function, c is written to using the write! method. Keep this method in mind, as we will be using it a lot; it is the primary output for toolips. There is also a component constructed via the p() method. This just creates a p. The id of the p will be its name, \"helloworld\", and the text; which modifies the inner text of a given element. The other special key is :children, which is of type Vector{Servable}. This will be any children to write to the stream inside of this tag. Children are usually added via the push!(::Servable, ::Servable) method.","category":"page"},{"location":"projects/#fourofour","page":"projects","title":"fourofour","text":"","category":"section"},{"location":"projects/","page":"projects","title":"projects","text":"fourofour = route(\"404\") do c\n    write!(c, p(\"404message\", text = \"404, not found!\"))\nend","category":"page"},{"location":"projects/","page":"projects","title":"projects","text":"The fourofour is made as a global variable of type Route, rather than as a function.","category":"page"},{"location":"projects/#command-line-interface","page":"projects","title":"command line interface","text":"","category":"section"},{"location":"projects/","page":"projects","title":"projects","text":"We have a few different options when it comes to starting the server. These options of course come with all toolips servers. The first of which is to load a server as a module. Most modular servers will use the Module.start() method, just like our project ToolipsTutorial does above. This is ideal if","category":"page"},{"location":"projects/","page":"projects","title":"projects","text":"You want to try someone else's Toolips Application.\nThe module you are working with is an Application.\nThe module you are working with is an extension; then the module is used","category":"page"},{"location":"projects/","page":"projects","title":"projects","text":"inside of another project, just to be clear.","category":"page"},{"location":"projects/","page":"projects","title":"projects","text":"using Pkg\nPkg.add(url = \"https://github.com/ChifiSource/ToolipsApp.jl\")\nusing ToolipsApp\nToolipsAppServer = ToolipsApp.start()","category":"page"},{"location":"projects/","page":"projects","title":"projects","text":"Alternatively, we can always git clone the repository, or with a project we started serve our project. This is ideal if","category":"page"},{"location":"projects/","page":"projects","title":"projects","text":"You want to put the server into production.\nYou want to develop the project. \n","category":"page"},{"location":"projects/","page":"projects","title":"projects","text":"We can start the server in this way by utilizing the environment files discussed before. This is done either via the include(\"\") method in the REPL, or via the -L parameter in Bash.","category":"page"},{"location":"projects/","page":"projects","title":"projects","text":"pwd()\n\"~/dev/ToolipsTutorial\"\ninclude(\"dev.jl\")\n#==\n[ Info: Precompiling ToolipsTutorial [9dd80660-3bd1-4940-be1d-3a5faeb076a0]\n[2022-06-14T18:50:45.970]: Toolips Server starting on port 8000\n[2022-06-14T18:50:46.521]: Successfully started server on port 8000\n[2022-06-14T18:50:46.966]: You may visit it now at http://127.0.0.1:8000\n==#","category":"page"},{"location":"projects/","page":"projects","title":"projects","text":"julia -L dev.jl\n[ Info: Precompiling ToolipsTutorial [9dd80660-3bd1-4940-be1d-3a5faeb076a0]\n[2022-06-14T18:50:45.970]: Toolips Server starting on port 8000\n[2022-06-14T18:50:46.521]: Successfully started server on port 8000\n[2022-06-14T18:50:46.966]: You may visit it now at http://127.0.0.1:8000","category":"page"},{"location":"projects/","page":"projects","title":"projects","text":"Wow now you can see the exact date and time at which I did that, cool. Anyway, with our new toolips server running, we can introspect its routes:","category":"page"},{"location":"projects/","page":"projects","title":"projects","text":"ToolipsTutorialServer.routes\nDict{String, Function} with 3 entries:\n  \"404\"              => #1\n  \"/\"                => home\n  \"/modifier/linker\" => document_linker\n  julia> typeof(ToolipsTutorialServer)\n  WebServer","category":"page"},{"location":"projects/","page":"projects","title":"projects","text":"The /modifier/linker route is provided to us by our Modifier extension. We also see that the type of this new variable is WebServer. Viewing the server in the web-browser yields us a small p with a label \"hello world!\". We can also route the server using the route! method, or access extensions and routes by indexing. This is the same way we would use the route() function as is done in our source file. We access Connection extensions by indexing a Connection with a Symbol. We can also access and change routes by indexing with a String. This same methodology is also applied to the WebServer, so we can index it in the same way, as well.","category":"page"},{"location":"projects/","page":"projects","title":"projects","text":"route!(ToolipsTutorialServer, \"/cupcakes\") do c::Connection\n    write!(c, \"emmy LOVES CUPCAAAKES\")\n    c[:logger].log(1, \"hello\")\nend\n\n[2022-06-14T19:29:32.180]: hello\n\"emmy LOVES CUPCAAAKES\"","category":"page"},{"location":"projects/","page":"projects","title":"projects","text":"Let's develop our emmy loves cupcakes app a bit further, by instead making it our project route function. Don't close up the REPL, though! we will still be using it!","category":"page"},{"location":"projects/#making-applications","page":"projects","title":"making applications","text":"","category":"section"},{"location":"projects/","page":"projects","title":"projects","text":"Lets return to our project source file,","category":"page"},{"location":"projects/","page":"projects","title":"projects","text":"function home(c::Connection)\n    redclass = Style(\"redtxt\", color = \"red\")\n    blueclass = Style(\"bluetxt\", color = \"lightblue\")\n    heading = h(\"cupkakes\", 1, text = \"Cupcakes\")\n    write!(c, p(\"clicktod\",\n    text = \"click to make the heading change color; double click to send to red.\"))\n    write!(c, components(redclass, blueclass))\n    on(c, heading, \"click\") do cm::ComponentModifier\n        style!(cm, heading, blueclass)\n    end\n    on(c, heading, \"dblclick\") do cm::ComponentModifier\n        style!(cm, heading, redclass)\n    end\n    write!(c, heading)\nend","category":"page"},{"location":"projects/","page":"projects","title":"projects","text":"Here I added an on() method call. This method call allows us to modify components on events. In this example, clicking will make the heading invisible. It is incredibly easy, but incredibly possible! The last step is going to be running the route! method on our WebServer.","category":"page"},{"location":"projects/","page":"projects","title":"projects","text":"route!(ToolipsTutorialServer, \"/\", ToolipsTutorial.home)","category":"page"},{"location":"projects/","page":"projects","title":"projects","text":"Now, we can finally visit; and click to change the color! Hopefully this little overview got you both familiar with Toolips projects, as well as reactivity. If you would like to try this project out for yourself, here is a link to the source.","category":"page"},{"location":"projects/#deploying-a-toolips-server","page":"projects","title":"deploying a toolips server","text":"","category":"section"},{"location":"projects/","page":"projects","title":"projects","text":"Toolips projects can very easily be deployed with SSL. This overview will demonstrate an example of deploying a non-containerized Toolips.jl project with NGINX. This is because this is likely the most interpretable overview to carry into deploying any project. We will be deploying toolips app with SSL on my server.","category":"page"},{"location":"projects/#tech-stack","page":"projects","title":"tech stack","text":"","category":"section"},{"location":"projects/","page":"projects","title":"projects","text":"Julia 1.7.2\nToolips.jl 0.1.0\nNGINX nginx/1.18.0 (Ubuntu)\nUbuntu 22.04 LTS (GNU/Linux 5.15.0-37-generic x86_64)\nSupervisord 4.2.1","category":"page"},{"location":"projects/#proxy-pass","page":"projects","title":"proxy pass","text":"","category":"section"},{"location":"projects/","page":"projects","title":"projects","text":"The first thing we are going to need to do is create our server configuration for nginx. This will involve listening on port 80 and     then forwarding any incoming connections to the port of our server. This also assumes that your domain or IP has already been routed to your DNS and under normal circumstances your domain or IP would be servable. We will go ahead and ssh into our server:","category":"page"},{"location":"projects/","page":"projects","title":"projects","text":"ssh emmac@xx.xxx.xxx","category":"page"},{"location":"projects/","page":"projects","title":"projects","text":"If you do not have nginx, we are going to need it.","category":"page"},{"location":"projects/","page":"projects","title":"projects","text":"sudo apt install nginx","category":"page"},{"location":"projects/","page":"projects","title":"projects","text":"Now we need to make our nginx server configuration. This is done by creating a new configuration file at the path /etc/nginx/conf.d","category":"page"},{"location":"projects/","page":"projects","title":"projects","text":"cd /etc/nginx/conf.d\nnano toolipsapp.conf","category":"page"},{"location":"projects/","page":"projects","title":"projects","text":"Now we will add a new server, and create a proxy pass.","category":"page"},{"location":"projects/","page":"projects","title":"projects","text":"server {\n    server_name toolips.app;\n\n    location / {\n        proxy_pass http://127.0.0.1:8001;\n        proxy_set_header Host $host;\n        proxy_set_header X-Forwarded-For $proxy_add_x_forwarded_for;\n    }\n}","category":"page"},{"location":"projects/","page":"projects","title":"projects","text":"Next, reload your configuration","category":"page"},{"location":"projects/","page":"projects","title":"projects","text":"nginx -s reload","category":"page"},{"location":"projects/","page":"projects","title":"projects","text":"I proxy pass this to http://127.0.0.1:8001. Now lets get our project files setup. We have the choice with toolips to use the project as both a module and a file path. In most cases, when deploying you are probably going to want to have access to the local files of a toolips application, so we are going to do the latter. In order to do so, the first step is to clone the module to our machine with git or scp it over. I like to put mine into the directory /var/www , but this is a matter of personal preference. Now that we have our project in its folder at /var/www, we can create a supervisor configuration. Supervisor allows us to run the application without actually being behind the terminal. However, it is also a pretty good idea to go ahead and test the server before starting your supervisor. So cd to your directory and include dev.jl. Try and visit your domain, and if it is not serving then you know something is likely wrong with either your DNS or nginx configuration. When you are ready to configure your supervisor, the configuration files are in /etc/supervisor/conf.d","category":"page"},{"location":"projects/","page":"projects","title":"projects","text":"cd /etc/supervisor/conf.d\nnano","category":"page"},{"location":"projects/","page":"projects","title":"projects","text":"You'll want to use the -L argument to start Julia with, this will automatically load the file and begin a new Julia session.","category":"page"},{"location":"projects/","page":"projects","title":"projects","text":"[program:toolipsapp]\ndirectory=/var/www/ToolipsApp.jl\ncommand=/opt/julia-1.7.3/bin/julia -L prod.jl\nautostart=true\nautorestart=true\nstopasgroup=true\nkillasgroup=true","category":"page"},{"location":"projects/","page":"projects","title":"projects","text":"Finally, we need to reload supervisor.","category":"page"},{"location":"projects/","page":"projects","title":"projects","text":"service supervisor reload","category":"page"},{"location":"projects/","page":"projects","title":"projects","text":"And if all is well, your server should be up and ready to go!","category":"page"}]
}
